<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"m1nilong.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.21.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="已结坑！大概是 codeforces 上 2600~2900 的带有 data structures 标签的一些题。 树上问题CF418D题目链接 首先可以倍增找到 $(u,v)$ 中间的断点 $t$（ $t$ 和左边都去 $u$，右边都去 $v$）。然后就可以把树分成两部分（这里注意如果 $t&#x3D;lca(u,v)$ 不能直接取子树），然后就是求 $\max(dis(u,S1),dis(v">
<meta property="og:type" content="article">
<meta property="og:title" content="minilong&#39;s blog">
<meta property="og:url" content="http://m1nilong.github.io/2024/09/27/%E3%80%90%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95%E3%80%91ds%E5%90%88%E9%9B%86/index.html">
<meta property="og:site_name" content="minilong&#39;s blog">
<meta property="og:description" content="已结坑！大概是 codeforces 上 2600~2900 的带有 data structures 标签的一些题。 树上问题CF418D题目链接 首先可以倍增找到 $(u,v)$ 中间的断点 $t$（ $t$ 和左边都去 $u$，右边都去 $v$）。然后就可以把树分成两部分（这里注意如果 $t&#x3D;lca(u,v)$ 不能直接取子树），然后就是求 $\max(dis(u,S1),dis(v">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-09-27T07:13:11.739Z">
<meta property="article:modified_time" content="2024-09-27T07:04:59.742Z">
<meta property="article:author" content="MiniLong">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://m1nilong.github.io/2024/09/27/%E3%80%90%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95%E3%80%91ds%E5%90%88%E9%9B%86/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://m1nilong.github.io/2024/09/27/%E3%80%90%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95%E3%80%91ds%E5%90%88%E9%9B%86/","path":"2024/09/27/【做题记录】ds合集/","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title> | minilong's blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">minilong's blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98"><span class="nav-number">1.</span> <span class="nav-text">树上问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CF418D"><span class="nav-number">1.0.1.</span> <span class="nav-text">CF418D</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF741D"><span class="nav-number">1.0.2.</span> <span class="nav-text">CF741D</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF763D"><span class="nav-number">1.0.3.</span> <span class="nav-text">CF763D</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF776F"><span class="nav-number">1.0.4.</span> <span class="nav-text">CF776F</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF925E"><span class="nav-number">1.0.5.</span> <span class="nav-text">CF925E</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF833D"><span class="nav-number">1.0.6.</span> <span class="nav-text">CF833D</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF986E"><span class="nav-number">1.0.7.</span> <span class="nav-text">CF986E</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF983E"><span class="nav-number">1.0.8.</span> <span class="nav-text">CF983E</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1039D"><span class="nav-number">1.0.9.</span> <span class="nav-text">CF1039D</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1083C"><span class="nav-number">1.0.10.</span> <span class="nav-text">CF1083C</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1088F"><span class="nav-number">1.0.11.</span> <span class="nav-text">CF1088F</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#P2056"><span class="nav-number">1.0.12.</span> <span class="nav-text">P2056</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1413F"><span class="nav-number">1.0.13.</span> <span class="nav-text">CF1413F</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1479D"><span class="nav-number">1.0.14.</span> <span class="nav-text">CF1479D</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BZOJ3252"><span class="nav-number">1.0.15.</span> <span class="nav-text">BZOJ3252</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF526G"><span class="nav-number">1.0.16.</span> <span class="nav-text">CF526G</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1633F"><span class="nav-number">1.0.17.</span> <span class="nav-text">CF1633F</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1654G"><span class="nav-number">1.0.18.</span> <span class="nav-text">CF1654G</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1749F"><span class="nav-number">1.0.19.</span> <span class="nav-text">CF1749F</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1810F"><span class="nav-number">1.0.20.</span> <span class="nav-text">CF1810F</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1827D"><span class="nav-number">1.0.21.</span> <span class="nav-text">CF1827D</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1904F"><span class="nav-number">1.0.22.</span> <span class="nav-text">CF1904F</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1935F"><span class="nav-number">1.0.23.</span> <span class="nav-text">CF1935F</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1976F"><span class="nav-number">1.0.24.</span> <span class="nav-text">CF1976F</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%BE%E4%B8%8A%E9%97%AE%E9%A2%98"><span class="nav-number">2.</span> <span class="nav-text">图上问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CF280D"><span class="nav-number">2.0.1.</span> <span class="nav-text">CF280D</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF757F"><span class="nav-number">2.0.2.</span> <span class="nav-text">CF757F</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF878C"><span class="nav-number">2.0.3.</span> <span class="nav-text">CF878C</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF811E"><span class="nav-number">2.0.4.</span> <span class="nav-text">CF811E</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF903G"><span class="nav-number">2.0.5.</span> <span class="nav-text">CF903G</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#P4151"><span class="nav-number">2.0.6.</span> <span class="nav-text">P4151</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF938G"><span class="nav-number">2.0.7.</span> <span class="nav-text">CF938G</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#P7520"><span class="nav-number">2.0.8.</span> <span class="nav-text">P7520</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1348F"><span class="nav-number">2.0.9.</span> <span class="nav-text">CF1348F</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1419F"><span class="nav-number">2.0.10.</span> <span class="nav-text">CF1419F</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1439B"><span class="nav-number">2.0.11.</span> <span class="nav-text">CF1439B</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1550F"><span class="nav-number">2.0.12.</span> <span class="nav-text">CF1550F</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#P6628"><span class="nav-number">2.0.13.</span> <span class="nav-text">P6628</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1682F"><span class="nav-number">2.0.14.</span> <span class="nav-text">CF1682F</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E6%B2%BB%E9%97%AE%E9%A2%98"><span class="nav-number">3.</span> <span class="nav-text">分治问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CF452F"><span class="nav-number">3.0.1.</span> <span class="nav-text">CF452F</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF480E"><span class="nav-number">3.0.2.</span> <span class="nav-text">CF480E</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF549F"><span class="nav-number">3.0.3.</span> <span class="nav-text">CF549F</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF750E"><span class="nav-number">3.0.4.</span> <span class="nav-text">CF750E</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF763E"><span class="nav-number">3.0.5.</span> <span class="nav-text">CF763E</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF848C"><span class="nav-number">3.0.6.</span> <span class="nav-text">CF848C</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1004F"><span class="nav-number">3.0.7.</span> <span class="nav-text">CF1004F</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1140F"><span class="nav-number">3.0.8.</span> <span class="nav-text">CF1140F</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1316F"><span class="nav-number">3.0.9.</span> <span class="nav-text">CF1316F</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1371F"><span class="nav-number">3.0.10.</span> <span class="nav-text">CF1371F</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1373G"><span class="nav-number">3.0.11.</span> <span class="nav-text">CF1373G</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1379F2"><span class="nav-number">3.0.12.</span> <span class="nav-text">CF1379F2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1439C"><span class="nav-number">3.0.13.</span> <span class="nav-text">CF1439C</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1386C"><span class="nav-number">3.0.14.</span> <span class="nav-text">CF1386C</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1442D"><span class="nav-number">3.0.15.</span> <span class="nav-text">CF1442D</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1648D"><span class="nav-number">3.0.16.</span> <span class="nav-text">CF1648D</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1654F"><span class="nav-number">3.0.17.</span> <span class="nav-text">CF1654F</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1693D"><span class="nav-number">3.0.18.</span> <span class="nav-text">CF1693D</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1730E"><span class="nav-number">3.0.19.</span> <span class="nav-text">CF1730E</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%8D%E9%97%AE%E9%A2%98"><span class="nav-number">4.</span> <span class="nav-text">位问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CF241B"><span class="nav-number">4.0.1.</span> <span class="nav-text">CF241B</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF633G"><span class="nav-number">4.0.2.</span> <span class="nav-text">CF633G</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF796F"><span class="nav-number">4.0.3.</span> <span class="nav-text">CF796F</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1511G"><span class="nav-number">4.0.4.</span> <span class="nav-text">CF1511G</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1730F"><span class="nav-number">4.0.5.</span> <span class="nav-text">CF1730F</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83%E9%97%AE%E9%A2%98"><span class="nav-number">5.</span> <span class="nav-text">贪心问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CF30E"><span class="nav-number">5.0.1.</span> <span class="nav-text">CF30E</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF187E"><span class="nav-number">5.0.2.</span> <span class="nav-text">CF187E</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF196D"><span class="nav-number">5.0.3.</span> <span class="nav-text">CF196D</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF436E"><span class="nav-number">5.0.4.</span> <span class="nav-text">CF436E</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF524F"><span class="nav-number">5.0.5.</span> <span class="nav-text">CF524F</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF625E"><span class="nav-number">5.0.6.</span> <span class="nav-text">CF625E</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF671D"><span class="nav-number">5.0.7.</span> <span class="nav-text">CF671D</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF797F"><span class="nav-number">5.0.8.</span> <span class="nav-text">CF797F</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF935F"><span class="nav-number">5.0.9.</span> <span class="nav-text">CF935F</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1051G"><span class="nav-number">5.0.10.</span> <span class="nav-text">CF1051G</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1137E"><span class="nav-number">5.0.11.</span> <span class="nav-text">CF1137E</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1238G"><span class="nav-number">5.0.12.</span> <span class="nav-text">CF1238G</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1446D2"><span class="nav-number">5.0.13.</span> <span class="nav-text">CF1446D2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1469F"><span class="nav-number">5.0.14.</span> <span class="nav-text">CF1469F</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1503D"><span class="nav-number">5.0.15.</span> <span class="nav-text">CF1503D</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1539F"><span class="nav-number">5.0.16.</span> <span class="nav-text">CF1539F</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1566F"><span class="nav-number">5.0.17.</span> <span class="nav-text">CF1566F</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1601D"><span class="nav-number">5.0.18.</span> <span class="nav-text">CF1601D</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1601E"><span class="nav-number">5.0.19.</span> <span class="nav-text">CF1601E</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1621F"><span class="nav-number">5.0.20.</span> <span class="nav-text">CF1621F</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1635F"><span class="nav-number">5.0.21.</span> <span class="nav-text">CF1635F</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1672H"><span class="nav-number">5.0.22.</span> <span class="nav-text">CF1672H</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1699E"><span class="nav-number">5.0.23.</span> <span class="nav-text">CF1699E</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1793E"><span class="nav-number">5.0.24.</span> <span class="nav-text">CF1793E</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1720E"><span class="nav-number">5.0.25.</span> <span class="nav-text">CF1720E</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1844F1"><span class="nav-number">5.0.26.</span> <span class="nav-text">CF1844F1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1893D"><span class="nav-number">5.0.27.</span> <span class="nav-text">CF1893D</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF1919F2"><span class="nav-number">5.0.28.</span> <span class="nav-text">CF1919F2</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">MiniLong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">30</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://m1nilong.github.io/2024/09/27/%E3%80%90%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95%E3%80%91ds%E5%90%88%E9%9B%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MiniLong">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="minilong's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | minilong's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-09-27 15:13:11 / 修改时间：15:04:59" itemprop="dateCreated datePublished" datetime="2024-09-27T15:13:11+08:00">2024-09-27</time>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>30k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>55 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>已结坑！大概是 codeforces 上 2600~2900 的带有 data structures 标签的一些题。</p>
<h1 id="树上问题"><a href="#树上问题" class="headerlink" title="树上问题"></a>树上问题</h1><h3 id="CF418D"><a href="#CF418D" class="headerlink" title="CF418D"></a>CF418D</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF418D">题目链接</a></p>
<p>首先可以倍增找到 $(u,v)$ 中间的断点 $t$（ $t$ 和左边都去 $u$，右边都去 $v$）。然后就可以把树分成两部分（这里注意如果 $t&#x3D;lca(u,v)$ 不能直接取子树），然后就是求 $\max(dis(u,S1),dis(v,S2))$。问题就是点到一个联通块的距离，且这个联通块是一个完整子树或树减去子树，在 dfn 序上至多分成两个区间。这个问题就随便做了，可以离线下来树上扫描线，也可以直接在 dfn 序上合并直径（最大距离一定是到直径两端点之一），或者树剖维护都可以。复杂度 $\Theta(n\log n)$。</p>
<h3 id="CF741D"><a href="#CF741D" class="headerlink" title="CF741D"></a>CF741D</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF741D">题目链接</a></p>
<p>其实就是求经过每个节点 $u$ 且两端在 $u$ 子树中的最长合法路径。一个路径合法当且仅当不超过一个字符出现奇数次，考虑将出现次数的奇偶性状压，那么就是找 $u$ 中两个不同子树的点对，满足它们到根的路径状态异或和的大小不超过 $1$，记录一下每个点的深度和状态，枚举奇数的位置就行，dsu on tree 处理，开个桶记录 $2^{22}$ 个状态就行。复杂度 $\Theta(nc\log n)$​。</p>
<h3 id="CF763D"><a href="#CF763D" class="headerlink" title="CF763D"></a>CF763D</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF763D">题目链接</a></p>
<p>不同构肯定树 hash，考虑树上扫描线，维护所有子树的 hash 值的桶。每次根从 $u$ 转移到 $v$ 时，会删掉以 $u$ 为根的整棵树，加入以 $v$ 为根的整棵树，加入以 $u$ 为根除了 $v$ 子树以外的树。map 记录出现次数就行，复杂度 $\Theta(n\log n)$。</p>
<h3 id="CF776F"><a href="#CF776F" class="headerlink" title="CF776F"></a>CF776F</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF776F">题目链接</a></p>
<p>考虑这些区域会形成一棵树，可以暴力处理一下编号。然后就是在一棵树上染色，考虑从小往大染色。颜色是 $1$ 的显然只有一个点 $u$，那么颜色是 $2$ 的点在 $u$ 的所有子树中都不能超过一个，颜色为 $3$ 的点可以在颜色 $2$ 到 $u$ 的路径上，也可以在颜色 $2$ 的子树中。发现这个东西很像点分治的形式，于是模仿点分治，将每层都染成同一个颜色，个数不超过 $\Theta(\log n)$。复杂度 $\Theta(n\log n)$。</p>
<h3 id="CF925E"><a href="#CF925E" class="headerlink" title="CF925E"></a>CF925E</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF925E">题目链接</a></p>
<p>假设树上每个点的权值是 $a_i$，初始 $a_i &#x3D; t_i$。那么变成黑点相当于链减 $1$，变白点相当于链加 $1$。现在就是要支持：区间加减 $1$，单点标记，询问全局没标记的点小于 $0$ 的个数。这个可以分块 $\Theta(n\sqrt{n} \log n)$ 做，空间 $\Theta(n\sqrt{n})$ 类似 <a target="_blank" rel="noopener" href="https://uoj.ac/problem/435">这题</a>。但是考虑 $\Theta(n\sqrt{n})$ 的做法，空间线性。直接对询问分块，考虑将每 $B$ 个询问一起做，那么记录每个点在前面处理完之后的权值 $a_i$，然后考虑这 $\Theta(B)$ 个点的贡献。将这 $\Theta(B)$ 个点建虚树，每条边加的值都相等，那么将每个点都挂到它所在的虚边的深度大的那个点上然后排序，然后每次链加可以暴力跳祖先 $\Theta(B)$ 个点，然后再对每条虚边记录指针 $pos_i$ 为当前第一个 $&lt;0$ 的位置，每次加会使指针移动 $\Theta(1)$ 个位置（因为只会 +1 或 -1）。排序部分可以把 $n$ 个点放到一起基数排序，然后复杂度就是 $\Theta(n\sqrt{n})$ 了。</p>
<h3 id="CF833D"><a href="#CF833D" class="headerlink" title="CF833D"></a>CF833D</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF833D">题目链接</a></p>
<p>路径数数考虑点分治，那么就是要考虑一堆三元组 $(val,x,y)$ 表示路径的权值积，黑色点 $x$ 个，白色点 $y$ 个。那么就是要找一堆三元组对，$(val1,x,y),(val2,a,b)$ 满足 $\dfrac{1}{2} \le \dfrac{a+x}{b+y} \le 2$，化简一下就是<br>$$<br>\left{<br>             \begin{array}{<strong>lr</strong>}<br>             2a-b\ge y-2x<br>             \<br>             2b-a\ge x-2y<br>             \end{array}<br>\right.<br>$$<br>设 $x_i &#x3D; 2a-b,y_i &#x3D; 2b-a$ 为询问点，$x_i &#x3D; b-2a,y_i &#x3D; a-2b$ 为插入点，那么就是要对每个询问点找到所有 $x_j \le x_i,y_j \le y_i$ 的乘积，可以简单二维数点。那复杂度就是 $\Theta(n\log^2 n)$，但是直接搞会算两次，就成平方了，然后可以写个 cdq 三只 $\log n$，还是能过。</p>
<h3 id="CF986E"><a href="#CF986E" class="headerlink" title="CF986E"></a>CF986E</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF986E">题目链接</a></p>
<p>把每个数的所有质因子找出来，然后对每种质因子用动态开点线段树维护，然后询问枚举 $w$ 的因子搞，暴力这样做是 $\Theta(n\log^2 n \log V)$ 的，无法通过。发现不用树剖，其实就是要求 $\Theta(n\log V)$ 次一个点到根上含有 $p$ 质因子的有多少个。考虑离线，考虑对每个质因子单独处理，把 $w$ 的所有质因子 $p$ 处挂 $u,v,lca(u,v),fa(lca(u,v))$ 四个询问，然后把所有含有 $w$ 质因子的点拿出来，子树加，单点查即可。复杂度  $\Theta(n\log n \log V)$。 </p>
<h3 id="CF983E"><a href="#CF983E" class="headerlink" title="CF983E"></a>CF983E</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF983E">题目链接</a></p>
<p>先考虑每个询问暴力做，发现把 $(u,v)$ 的路径拿出来，一定是先坐一个能走最长的车，再换乘，直到走到 $v$。如果 $v$ 是 $u$ 的祖先肯定很好做，就是从每个点往上一直走，首先预处理从每个点往上坐 $1$ 条线走到最远哪里，这个可以把每个路径的 $u,v$ 处插入一个插入标记，在 $lca(u,v)$ 插入一个删除标记，然后直接线段树合并就能做到单 $\log$。然后就是倍增处理走 $2^i$ 步最浅到哪，两边同时跳到 $lca$ 下面的点，然后看看是否有路径在 $(u’,v’)$ 子树中，就是个二维数点，主席树线段树合并随便做就行。复杂度 $\Theta(n\log n)$。</p>
<h3 id="CF1039D"><a href="#CF1039D" class="headerlink" title="CF1039D"></a>CF1039D</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1039D">题目链接</a></p>
<p>注意到路径不能重复，所以考虑根号分治。当 $k \le B$ 时，考虑单次暴力，设二元组 $f_u$ 为 $u$ 的子树中能选出多少条长度 $k$ 路径，且满足第一关键字的情况下能有最多多少从根往下的空白。显然 $\Theta(n)$ 做即可，复杂度 $\Theta(nB)$。当 $k &gt; B$ 时，此时答案不超过 $\dfrac{n}{B}$，且答案有单调性，所以考虑对于每个答案，二分它的边界，用上面的方法暴力验证，复杂度 $\Theta(\dfrac{n^2 \log n}{B})$。当 $B$ 取 $\sqrt{n\log n}$ 时，有最优复杂度 $\Theta(n \sqrt{n\log n})$。</p>
<h3 id="CF1083C"><a href="#CF1083C" class="headerlink" title="CF1083C"></a>CF1083C</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1083C">题目链接</a></p>
<p>考虑从 $mex$ 入手，怎么判断权值为 $[0,i]$ 的区间是否组成一个链。判断若干个点是否组成一条链当然可以使用线段树来合并，把左右儿子组成的链的 $4$ 个点拿出来，枚举这个新链的两个端点，判断其他两个点是否在这条链上（就是 $dis(x,u)+dis(x,v)&#x3D;dis(u,v)$）就行，然后再套个线段树二分，复杂度 $\Theta(n\log n)$。</p>
<h3 id="CF1088F"><a href="#CF1088F" class="headerlink" title="CF1088F"></a>CF1088F</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1088F">题目链接</a></p>
<p>首先感觉一下，发现重构出来的树以最小权值作为根时，也应该是父亲权值小于儿子的。因为如果父亲权值大于儿子，那么我可以找到深度最大的这样的点，删掉这个点和它父亲的连边，把它接到原本树上的父亲上（由于这个深度是最大的，所以子树肯定没有它原本树上的父亲），通过这样的调整一定更优，于是就可以调整成一个父亲权值小于儿子的了。那么就是考虑连到比它小的点，如果连到一个不是祖先的点，那么找到这个点和它的 $lca$，这个 $lca$ 的权值比它们都小，而且距离更近，所以肯定更优。那么就是在原树上找到一个祖先连边了，直接枚举 $\lceil \log_2 dis(u,v)\rceil$，把 $u$ 到根的链分成 $\Theta(\log n)$ 段，然后在每个段上找到一个最小值连就行，其实就是这个段最顶上那个点，就是 $u$ 的 $2^k$ 祖先（注意一下边界），权值是 $a_u + \min a_v (1+k)$。倍增处理即可，复杂度 $\Theta(n\log n)$。</p>
<h3 id="P2056"><a href="#P2056" class="headerlink" title="P2056"></a>P2056</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2056">题目链接</a></p>
<p>每个点点权 $\in \set{0,1}$，每次翻转单点，求两个 $0$ 的距离最大。</p>
<ul>
<li>最大距离考虑直径，线段树维护每个区间的直径，由于边权非负，可以贪心合并。（大区间的直径端点一定在左右儿子的 $4$ 个端点中取）复杂度 $\Theta(n\log n)$，<strong>不支持负边权</strong>。</li>
<li>动态查询路径考虑动态点分治，用堆维护每个点 $u$ 子树（点分树）中到父亲（点分树）的所有距离 $q_u$，用堆 $son_u$ 维护 $u$ 到所有儿子（点分树）的距离（这是将每个 $q_v$ 中最大的放进来，<strong>每个子树只放一个</strong>），再用一个全局的堆 $st$ 维护所有 $son_u$ 最大和次大的和。注意堆要支持删除，就对每个堆再开一个删除的堆（把删除的东西放入），取出时若两个堆顶相同就同时弹出。修改先删 $q$，然后更新 $son_{fa}$，然后再更新 $st$。复杂度 $\Theta(n\log ^ 2 n)$​，<strong>支持负边权</strong>。</li>
<li>最大距离考虑括号序列，dfs 进入一个点塞 $($，然后塞点编号，然后出来的时候塞 $)$。显然两点距离就是删除匹配的后 $)))((($ 的长度。考虑线段树维护每个点的 $r_u,l_u$ 表示删除匹配后这段区间的右括号、左括号个数，和最长长度 $dis$。转移如下<ul>
<li>$r_u &#x3D; r_{ls} + \max(0,r_{rs} - l_{ls}),l_u &#x3D; l_{rs} + \max(0,l_{ls} - r_{rs})$。</li>
<li>$dis_u &#x3D; \max(dis_{ls},dis_{rs},\max\limits_{i\le mid &lt;j} r_{[i,mid]} + |l_{[i,mid]}-r_{[mid+1,j]}|+l_{[mid+1,j]}) $<ul>
<li>$\max\limits_{i\le mid &lt;j} r_{[i,mid]} + |l_{[i,mid]}-r_{[mid+1,j]}|+l_{[mid+1,j]} &#x3D;\max((l_{[i,mid]}+r_{[i,mid]})+(l_{[mid+1,j]} - r_{[mid+1,j]}),(l_{[mid+1,j]}+r_{[mid+1,j]})-(l_{[i,mid]} - r_{[i,mid]}))$</li>
</ul>
</li>
<li>$addp_u &#x3D; \max l_{[l,i]}+r_{[l,i]}&#x3D;\max(addp_{ls},\max(r_{ls}+l_{ls}+subp_{rs},r_{ls}-l_{ls}+addp_{rs}))$</li>
<li>$adds_u &#x3D; \max l_{[i,r]}+r_{[i,r]} &#x3D; \max(adds_{rs},\max(l_{rs}+r_{rs}-subp_{ls},l_{rs} - r_{rs}+adds_{ls}))$</li>
<li>$subp_u &#x3D; \max l_{[l,i]} - r_{[l,i]} &#x3D; \max(subp_{ls},l_{ls} -r_{ls}+subp_{rs})$</li>
<li>$subs_u &#x3D; \max l_{[i,r]} - r_{[i,r]} &#x3D; \max(subs_{rs},l_{rs} - r_{rs}+subs_{ls})$​</li>
<li>复杂度 $\Theta(n\log n)$，<strong>不支持负边权</strong></li>
</ul>
</li>
</ul>
<h3 id="CF1413F"><a href="#CF1413F" class="headerlink" title="CF1413F"></a>CF1413F</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1413F">题目链接</a></p>
<p>记录 $sum_i$ 为 $i$ 到根的边权异或和，那么就是要找到两个点使得它们 $sum_u &#x3D; sum_v$ 且 $dis(u,v)$ 最大，且支持区间翻转。考虑用 P2056 直径的思路记录线段树每个节点 $sum&#x3D;0&#x2F;1$ 的直径，翻转的时候交换一下 $tr_{u,0},tr_{u,1}$ 即可。复杂度 $\Theta(n\log n)$。</p>
<h3 id="CF1479D"><a href="#CF1479D" class="headerlink" title="CF1479D"></a>CF1479D</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1479D">题目链接</a></p>
<p>路径数颜色，考虑主席树记录每个点到根的每个颜色出现次数模 $2$。如果出现了偶数次就是根到 $u$ 和根到 $v$ 的次数模 $2$ 异或起来是 $0$。可以考虑在主席树上二分找这个 $x$，那么就是要快速判断一段区间的颜色是否按位异或起来都是 $0$。用个异或哈希刻画这个东西就行了。复杂度 $\Theta(n \log n)$。</p>
<h3 id="BZOJ3252"><a href="#BZOJ3252" class="headerlink" title="BZOJ3252"></a>BZOJ3252</h3><p><a target="_blank" rel="noopener" href="https://vjudge.net.cn/problem/%E9%BB%91%E6%9A%97%E7%88%86%E7%82%B8-3252">题目链接</a></p>
<p>先考虑一个一个取是不是对的。显然是对的，因为如果一条路径在前两次没被选而被第一次选了，那么第一次肯定可以拿第二次的更优，矛盾了。那么再考虑贡献不能重复算怎么办，设 $maxn_u$ 为从 $u$ 到 $u$ 子树的一个叶子最长的一条路径（也就是长链），那么当 $u$ 子树里有被选的点时，$maxn_u$ 一定被选了，而且是第一次选 $u$ 子树内的点时就被选了，所以其他点不可能有 $u \to maxn_u$ 这条链上的贡献了。那么一个叶子的贡献就是它到它所在长链链顶的权值和，选出前 $k$ 大的即可，复杂度 $\Theta(n\log n)$。</p>
<h3 id="CF526G"><a href="#CF526G" class="headerlink" title="CF526G"></a>CF526G</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF526G">题目链接</a></p>
<p>这题是真牛。</p>
<p>考虑单次询问，那么把 $x$ 设为根，显然这 $y$ 条路径都是 $y$ 对叶子节点构成的，那么再考虑任意 $2k$ 个叶子是否存在一个构造使得能覆盖它们的虚树呢？答案是肯定的。把它们按照 dfn 序排序，每次把首尾配对即可。那么不考虑包含 $x$，就是要求选 $2k$ 个叶子使得它们构成的虚树权值和最大，这里可以运用 BZOJ3252 的长链剖分的做法 $\Theta(n)$ 做，然后如果不包含 $x$，即它们都在 $x$ 的同一棵子树里，那么删掉贡献最小的那个点，加上 $x$ 其他子树到它距离最大的那个就好了 。这样单次询问就可以在 $\Theta(n)$ 的复杂度内搞定。</p>
<p>考虑多次询问，每次询问的瓶颈在于每次都要长剖一次，很劣。我们发现每次距离 $x$ 最远的那个点，也就是直径的端点，一定会被选。所以，不妨把直径的两个端点分别作为根求答案取最大值。再额外选 $2y-1$ 个叶子，可以预处理出来选前 $i$ 个叶子的答案，与 BZOJ3252 一模一样。然后不包含 $x$ 的话证明 $x$ 所在长链一定不是前 $2y-1$ 个，所以可以删掉第 $2y-1$ 个换成 $x$ 的长链能让损失最小。但是考虑 $x$ 往上第一个遇到的长链，若把它去掉，$x$ 的长链还会额外贡献那条长链在 $x$ 到根这部分的长度，可能更优。所以再判断删除第 $2y-1$ 条链和 $x$ 往上第一条长链哪个更优就行。后者可以倍增找到，记录每个点被覆盖长链的排名就行。复杂度 $\Theta(n\log n)$。</p>
<h3 id="CF1633F"><a href="#CF1633F" class="headerlink" title="CF1633F"></a>CF1633F</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1633F">题目链接</a></p>
<p>考虑有完美匹配的充要条件，就是 $\sum\limits_u [2 | siz_u] &#x3D; \sum\limits_u [2 \nmid siz_u]$，且只会选择每个 $2\nmid siz_u$ 的 $(u,fa_u)$ 这些边。每次加入一个相当于把它到 $1$ 的路径上全部翻转奇偶性，用线段树维护每个区间的奇数、偶数 $siz_u$ 个数和每个奇数的 $siz_u$ 的 $id(u,fa_u)$ 之和，每次翻转直接交换奇偶即可，树剖维护一下，复杂度 $\Theta(n\log^2 n)$。</p>
<h3 id="CF1654G"><a href="#CF1654G" class="headerlink" title="CF1654G"></a>CF1654G</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1654G">题目链接</a></p>
<p>贪心地走，一定是走到一个点 $v$ 使得 $v$ 有相邻同高度的点，然后反复跳再下去，就是 $2h_u - h_v$。那么要最小化 $h_v$。考虑这样的 $v$ 的种类数量，因为每当出现一个两个高度为 $t$ 的相邻的点，就一定底下会多出来 $2t$ 个点，注意到是树形结构，所以 $\sum h_v &#x3D; \Theta(n)$ 的。那么 $h_v$ 就有 $\Theta(\sqrt{n})$ 种，设 $f_{i,j}$ 是从 $i$ 开始走到一个高度为 $j$ 的 $v$ 所需要初始最小动能。先从低往高转移，然后每个相同高度的联通块换根转移。复杂度 $\Theta(n\sqrt{n})$。</p>
<h3 id="CF1749F"><a href="#CF1749F" class="headerlink" title="CF1749F"></a>CF1749F</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1749F">题目链接</a></p>
<p>考虑到 $d$ 很小，不妨将所有更改挂到对应节点上，然后枚举查询节点的不高于 $d$ 级祖先。</p>
<p>更改时，先考虑 $lca(u,v)$ 子树内的贡献。可以开 $20$ 棵线段树维护每个距离的标记。对于链 $(u,v)$，可以在这条路径上每个点在 $[1,d]$ 这些线段树上加上 $k$，但是这样会算重，具体地，对于一个点 $x$，若它还有儿子 $y$ 被更改，那么 $y$ 子树中距离 $y$ 不超过 $d-1$ 的点会被多加 $k$。所以对于链 $(u,v)$ 上除了 $lca(u,v)$ 的点之外所有点都在 $[1,d-1]$ 这些线段树上减 $k$。查询的时候枚举 $u$ 的 $20$ 个祖先然后单点查询。这样复杂度是 $\Theta(nd\log^2 n+nd\log n)$，不平衡。注意到只是单点查，那么树上差分一下变成子树查询即可，复杂度 $\Theta(nd \log n)$。然后是 $lca(u,v)$ 子树以外的贡献，那么考虑直接枚举 $lca(u,v)$ 的不超过 $d$ 级祖先，在每个这样的点 $x$ 开 $20$ 个标记，表示 $x$ 子树到 $x$ 距离等于 $i$ 的标记。类似地，每次把 $tag_{x,0}$ 到 $tag_{x,d-dis(u,lca(u,v))}$ 加上 $k$，设 $x$ 在 $lca(u,v)$ 方向儿子为 $y$，把 $tag_{y,0}$ 到 $tag_{y,d-dis(u,lca(u,v))}$ 全部减去 $k$ 即可。复杂度 $\Theta(nd^2)$（当然可以做到 $\Theta(nd\log d)$）。</p>
<p>查询直接枚举 $u$ 的 $20$ 个祖先，然后子树求和就行，再加上标记，复杂度 $\Theta(n(d\log n+d))$。</p>
<p>所以总复杂度为 $\Theta(nd(\log n + d))$。</p>
<h3 id="CF1810F"><a href="#CF1810F" class="headerlink" title="CF1810F"></a>CF1810F</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1810F">题目链接</a></p>
<p>注意到答案应该不会超过 $\max a_i +\log_m{n}$，因为可以构造一个完全 $m$ 叉树。于是考虑枚举答案，然后来验证。设当前答案为 $ans$，显然先搞出来个深度为 $ans$ 的满 $m$ 叉树比较优，然后从后往前枚举值域 $i$，设当前空位为 $x$，每次使得 $x \leftarrow m(x - cnt_i),i\leftarrow i - 1$。若 $x$ 始终 $\ge 0$，那么就可行。考虑线段树维护这个东西，设每个区间要合法初始值最小为 $f_u$，使用最小初始值最后剩下 $g_u$，从 $l$ 到第一个有数值的位置设为 $tr_u$。合并的时候若 $m^{len_{ls} - tr_{ls}}g_{rs} \ge f_{ls}$，那么 $f_u &#x3D; f_{rs},g_u &#x3D; g_{ls}+m^{len_{ls}}(g_{rs} - f_{ls})$。否则设 $t&#x3D;\lceil \dfrac{f_{ls}-m^{len_{ls} - tr_{ls}}g_{rs}}{m^{len_{ls} - tr_{ls}+tr_{rs}}} \rceil$，那么 $f_u &#x3D; t+f_{rs},g_u &#x3D; g_{ls} + m^{tr_{ls}}(g_{rs}+t\cdot m^{len_{ls} - tr_{ls}+tr_{rs}}- f_{ls})$。每次单点改即可，复杂度 $\Theta(n\log n)$。</p>
<h3 id="CF1827D"><a href="#CF1827D" class="headerlink" title="CF1827D"></a>CF1827D</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1827D">题目链接</a></p>
<p>注意到有两个重心当且仅当存在一条边使得两个端点的子树 $siz$ 相等且等于 $\dfrac{n}{2}$。如果直接维护就是要维护 $\min |n-2siz_i|$，还要区间加 $1$ 减 $1$，比较麻烦。考虑这个点会在哪，感受一下发现肯定是在已经有的重心旁边，那么答案就是 $n-2maxson$，再更新一下重心就行（只会移动一步）。直接树剖维护，复杂度是 $\Theta(n\log^2 n)$。</p>
<p>但是可以单 $\log$，具体地，设重心在 $x$，$maxson&#x3D;k$，$id$ 为 $k$ 的编号。若加的是 $id$ 的子树里的点，判断 $id$ 是否能成为重心，如果可以 $id’ \leftarrow x,k\leftarrow \dfrac{n}{2},x\leftarrow id$，不然就是 $k \leftarrow k+1$。如果不在 $id$ 子树判断这个子树是否比 $id$ 子树更大，更新一下就行。用树状数组维护单点加，区间和，复杂度 $\Theta(n\log n)$。</p>
<h3 id="CF1904F"><a href="#CF1904F" class="headerlink" title="CF1904F"></a>CF1904F</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1904F">题目链接</a></p>
<p>注意到每个点点值不同，那么把小的连到大的，要求是个 dag 就行。用线段树优化建图，复杂度 $\Theta(n \log^2 n)$。</p>
<h3 id="CF1935F"><a href="#CF1935F" class="headerlink" title="CF1935F"></a>CF1935F</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1935F">题目链接</a></p>
<p>显然每次连边只可能是 $(x,x+1)$，且最多只有一次是 $(x,x+2)$​。那么对于每个 $(x,x+1)$，当前仅当它们在一个点的两个不同子树中时有用，于是把 $(x,x+1)$ 挂到 $lca(x,x+1)$ 上，每次用并查集合并。然后子树的父亲的可以记录每个 $sum_u$ 为 $u$ 子树中最浅的 $lca(x,x+1)$，如果 $u$ 的儿子 $v$ 的 $sum_v$ 深度比 $u$ 浅就可以连，然后如果还不联通的话就要连 $(u-1,u+1)$。复杂度 $\Theta(n\log n)$。</p>
<h3 id="CF1976F"><a href="#CF1976F" class="headerlink" title="CF1976F"></a>CF1976F</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1976F">题目链接</a></p>
<p>经典题。考虑根度数是 $1$，所以第一次肯定是选从根开始的一条路径，那肯定就是最深的那个叶子。然后第二次就可以选两个到根的链，也一定是两个叶子（选两个原因：有个经典结论是在树上选 $2k$ 个点一定存在 $k$ 条链并集是它们的虚树），这个就是 BZOJ3252，长剖之后每个叶子的权值就是它到链头的长度，排个序就好了。复杂度 $\Theta(n\log n)$​，瓶颈在排序。</p>
<h1 id="图上问题"><a href="#图上问题" class="headerlink" title="图上问题"></a>图上问题</h1><h3 id="CF280D"><a href="#CF280D" class="headerlink" title="CF280D"></a>CF280D</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF280D">题目链接</a></p>
<p>选 $k$ 个可以描述为一个费用流模型，可以模拟费用流来做，但我不会。注意到它是凸的，所以线段树维护 $k$ 大子段和，可以闵可夫斯基和合并。复杂度 $\Theta(nk\log n)$，有 $16$​ 倍常数。</p>
<p><del>没过</del></p>
<h3 id="CF757F"><a href="#CF757F" class="headerlink" title="CF757F"></a>CF757F</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF757F">题目链接</a></p>
<p>以 $s$ 为起点求一遍最短路，把所有 $dis(v) &#x3D; dis(u)+w$ 的 <strong>有向边</strong> $(u,v,w)$ 保留，形成一个 dag。也就是要问这个 dag 上删掉一个点使得最多有多少与 $s$ 不连通的点。那就是求新图上起点为 $s$ 的支配树上除了 $s$ 的最大 $siz$ 是多少，直接建支配树求即可。复杂度 $\Theta(n\log n)$。</p>
<h3 id="CF878C"><a href="#CF878C" class="headerlink" title="CF878C"></a>CF878C</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF878C">题目链接</a></p>
<p>单次可以对每个项目排序，然后每个人连到第一个小于它的人，答案就是缩点之后每个入度为 $0$ 的 scc 的点数和。这个图还有个性质，就是它是一个链状物，一个点只可能连到链后面的点。所以加边的时候只有返祖边会寄。于是先按第一个项目把这条链求出来，加边的时候如果遇到返祖边就直接用个并查集把之间的点并起来。复杂度 $\Theta(nk\log n)$，用 set 维护。</p>
<h3 id="CF811E"><a href="#CF811E" class="headerlink" title="CF811E"></a>CF811E</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF811E">题目链接</a></p>
<p>因为一列是完整的，所以考虑用线段树维护维护两端的每个点所在的联通块编号。合并的时候先把中间的两列合并，然后再看左右两边是否有联通块被中间合并的时候一起合并了，并查集维护即可。</p>
<h3 id="CF903G"><a href="#CF903G" class="headerlink" title="CF903G"></a>CF903G</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF903G">题目链接</a></p>
<p>最大流&#x3D;最小割。为了方便，设 $A_0 \to A_1,A_n \to A_{n+1}, w&#x3D;0$， $B$ 同理 注意到切在 $A,B$ 的边分别恰好割一条，设它们分别是 $x,y$。那么要付出的代价就是 $a_x+b_y + \sum\limits_{u_i \le x,v_i &gt;y} w_i$。因为只有 $a_x$ 会改变，不妨先处理出来 $f_i &#x3D; \min\limits_j b_j + \sum\limits_{u_k \le i, v_k &gt; j} w_k$。考虑扫描线，初始每个位置 $j$ 的值为 $b_j$，然后扫 $i$，每遇到一个 $u_k &#x3D; i$，把 $[0,v_k - 1]$ 加上 $w_k$，然后求全局 $\min$ 即可，就处理处理 $f$ 了。然后 $a_x$ 的话就用个 $set$ 维护单点改，全局 $\min$ 就行。复杂度 $\Theta(n\log n)$。</p>
<h3 id="P4151"><a href="#P4151" class="headerlink" title="P4151"></a>P4151</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4151">题目链接</a></p>
<p>注意到随便从 $s$ 走到 $t$ 搞个路径出来，然后可以任意选环。由于异或的性质，不需要把所有环都拿出来，那可以先搞出个 dfs 树出来，然后把每条非树边在上面形成的环搞出来做个线性基就行。复杂度 $\Theta(n\log n)$。</p>
<h3 id="CF938G"><a href="#CF938G" class="headerlink" title="CF938G"></a>CF938G</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF938G">题目链接</a></p>
<p>用 P4151 的结论，然后套一个线段树分治。考虑怎么维护 dfs 树，使用带权并查集，但是因为每次会 findrt，所以连的边不是真实的。那么在连 $(u,v)$ 时，先找到 $u$ 到根的异或和，和 $v$ 到根的异或和，把 $w$ 异或上它们，再连就行。复杂度 $\Theta(n\log n(\log n + \log V))$。</p>
<h3 id="P7520"><a href="#P7520" class="headerlink" title="P7520"></a>P7520</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P7520">题目链接</a></p>
<p>建出支配树，发现如果一个点会改变那么它的子树也会被改变。那么预处理每个点删了它父亲在原图的反图能走到哪些点，查询就查除了 $1\to u$ 的路径的那些点就行。复杂度 $\Theta(n(n+q))$。</p>
<h3 id="CF1348F"><a href="#CF1348F" class="headerlink" title="CF1348F"></a>CF1348F</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1348F">题目链接</a></p>
<p>考虑构造一组解，贪心地，按右端点、左端点排序，每个区间取最左边能取的值，用个 set 维护。考虑怎么搞两组解，感受一下就可以发现遇到一个区间，它本来还能取到更往左的值，但是已经被取了，那么就可能与那个先取的那个区间交换。具体地，考虑设 $L_i$ 为排列中的值 $i$ 其被取的区间左端点，$R_i$ 为右端点。那么考虑从小到大枚举每个值，就是要找到一个 $L_i \le j&lt;i\le R_j$，那么扫到一个值的时候往 $R_i$ 处插入 $i$ 以便到时候删除，然后用个 set 维护插入删除，每次二分找到一个 $\ge L_i$ 的可以了。复杂度 $\Theta(n\log n)$。</p>
<h3 id="CF1419F"><a href="#CF1419F" class="headerlink" title="CF1419F"></a>CF1419F</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1419F">题目链接</a></p>
<p>先把 $n$ 个点连边排序，依次加边。注意到一个点只能走到 $4$ 个不同的位置，所以当且仅当现在只有 $\le 4$ 个联通块时可能存在。所以当第一次只剩 $4,3,2$ 个联通块时判断一下，这里最多只有 $3$ 种情况。每次可以考虑枚举两个 $x,y$ 都不同的点，算出它们所在长方形的其他两个点，把这两个点标记上枚举的这两个点分别所在的联通块（在这些点上记录每个联通块到它最短距离），然后找到一个最优的点满足所有联通块到它的最远距离最小，更新答案。注意到有 $2$ 个联通块的时候不一定有上述情况，所以可以枚举两个点算它们之间的距离即可。具体可以使用 dsu 实现，复杂度 $\Theta(n^2 \log n)$。</p>
<h3 id="CF1439B"><a href="#CF1439B" class="headerlink" title="CF1439B"></a>CF1439B</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1439B">题目链接</a></p>
<p>考虑先把所有度数大于等于 $k$ 的点加入一个集合。然后计算出每个集合中的点邻居有多少个，然后如果有点邻居小于 $k$，那就把它删了。可以用堆维护，重复这个过程，最后如果有剩下的那就是第一合法的子集。考虑团怎么求，相似地，我们可以考虑枚举每个度数大于等于 $k-1$ 的点，重复上面的过程，只不过把下限调整为 $k-1$。考虑如果没有 $k-1$ 的点的话上面的点集肯定能找到，所以这个团肯定包括一个邻居 <strong>恰好</strong> $k-1$ 的点，那么我们枚举这些点，暴力 $\Theta(k^2)$ 判断这些点的邻居是否组成一个团。注意到一个团有 $\Theta(k^2)$ 条边，而边集是 $\Theta(m)$ 级别的，所以合法的 $k$ 肯定不超过 $\Theta(\sqrt{m})$，且邻居有 $k-1$ 个点的点最多有 $\Theta(\dfrac{m}{k})$ 个，所以复杂度为 $\Theta(mk)$ 即 $\Theta(m\sqrt{m})$。实现的时候会多带个 $\Theta(\log n)$，因为要查找 $(u,v)$ 是否有边。使用 unordered_map 会很慢很慢。</p>
<h3 id="CF1550F"><a href="#CF1550F" class="headerlink" title="CF1550F"></a>CF1550F</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1550F">题目链接</a></p>
<p>考虑两两连边，求出 mst，那么 $k$ 就要大于 mst 上路径边权最小值。考虑使用 boruvka 算法，那么就是每次从一个点出发，问最近能走到哪个不在同一联通块中的点。那么就说要从每个 $u$ 开始，看看 $u-d,u+d$ 左右两侧第一个不和 $u$ 在同一联通块的位置。由于 $u-d,u+d$ 是固定的，所以可以预处理出来这两个位置左右的第一个点。然后每次迭代之后对于每个点求出 $L_i,R_i$ 表示左边和右边第一个和它不同的点。这样就能做到 $\Theta(n\log n)$​ 了。</p>
<h3 id="P6628"><a href="#P6628" class="headerlink" title="P6628"></a>P6628</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P6628">题目链接</a></p>
<p>考虑对每个 $i$ 单独处理就是要走一个 $s \to i$ 的欧拉通路。那么就说要考虑度数+连通性，因为连边是 $|i-j|$，所以任何 $(i,j)$ 都可以转化为 $(i,i+1),(i+1,i+2)\cdots (j-1,j)$。然后先把 $m$ 条边加进来，再加入一条 $(s,i)$ 的虚边，对于所有奇数点排序相邻连边。然后连通性也是类似，把相邻两个不连通的点的边加入，求 mst 就行。（加虚边不影响连通性是因为如果 $(s,i)$ 删了之后不在同一联通块，那么就有一个联通块有恰好 $1$ 个奇数点，显然不可能）复杂度 $\Theta(n\log^2 n)$​。</p>
<h3 id="CF1682F"><a href="#CF1682F" class="headerlink" title="CF1682F"></a>CF1682F</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1682F">题目链接</a></p>
<p>其实把所有 $b_i &lt; 0$ 看成 $-b_i$ 个黑点，$b_i &gt; 0$ 看成 $b_i$ 个白点，那就是两两匹配最短长度和。那其实就是每个点往前面第一个与它不同颜色没匹配的匹配。直接统计是可以，但是不太方便。考虑一个 $(a_i,a_i + 1)$ 的贡献，由于保证 $b$ 之和是 $0$，所以必定有 $sum_{i-1} - sum_{l-1} &#x3D; -(sum_r - sum_{i-1})$。那么贡献就是 $(a_i - a_{i-1}) \cdot |sum_{i-1} - sum_{l-1}|$。那直接离线下来，二维数点即可，可以对 $sum$ 排序算 $[l+1,r]$ 之间的贡献，就可以用 bit 统计了。复杂度 $\Theta(n\log n)$。</p>
<h1 id="分治问题"><a href="#分治问题" class="headerlink" title="分治问题"></a>分治问题</h1><h3 id="CF452F"><a href="#CF452F" class="headerlink" title="CF452F"></a>CF452F</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF452F">题目链接</a></p>
<p>枚举 $i$，考虑差为 $k$，即 $a_i - k,a+k$ 是否在不同的两侧。把在 $i$ 前面的 $a_j$ 设为 $1$，就是要找以 $i$ 为中心半径在 $\min(a_i,n-a_i + 1)$ 的串是否是回文串。线段树维护即可。复杂度 $\Theta(n\log n)$​。</p>
<h3 id="CF480E"><a href="#CF480E" class="headerlink" title="CF480E"></a>CF480E</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF480E">题目链接</a></p>
<p>倒序加点处理，设 $f_{i,j}$ 为 $(i,j)$ 能往上走几步，$g_{i,j}$ 往下。每次加点 $(x,y)$ 只会影响 $f_{i,y},g_{i,y}$，可以 $\Theta(nk)$ 修改。考虑每次对答案的增加，显然是枚举 $x$ 这一行，然后 $[l,r]$ 合法当且仅当 $\min\limits_{k\in [l,r]} f_{x,k} + \min\limits_{k\in[l,r]} g_{x,k} - 1 \ge r - l + 1$。由于答案是单调的，所以直接枚举上次答案 $ans+1$，作为 $r-l+1$，做一个滑动窗口就行。复杂度 $\Theta(nk)$。</p>
<h3 id="CF549F"><a href="#CF549F" class="headerlink" title="CF549F"></a>CF549F</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF549F">题目链接</a></p>
<p>考虑分治，枚举最大值的一边，设最大值在左边，那么枚举 $i$，也就是问有多少个 $j$ 满足 $j\in [mid+1,r],sum_{mid} - sum_{j} \equiv sum_{mid} -sum_{i-1}-\max\limits_{p\in[i,mid]} a_p \pmod{k}$，可以考虑双指针实现。复杂度 $\Theta(n\log n)$。</p>
<h3 id="CF750E"><a href="#CF750E" class="headerlink" title="CF750E"></a>CF750E</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF750E">题目链接</a></p>
<p>考虑 $[1,n]$ 怎么做，设 $f_{i,0&#x2F;1&#x2F;2&#x2F;3&#x2F;4}$ 为前 $i$ 个匹配到 $\empty,2,0,1,7$ 的最小代价。转移为设当前字符是 $x$（第 $x$ 个），那么有 $f_{i,x-1} &#x3D; f_{i-1,x-1}+1,f_{i,x}&#x3D;\min{f_{i-1,x},f_{i-1,x-1}},f_{i,j}&#x3D;f_{i-1,j}(j\neq x \and j\neq x-1)$。特别地，如果这一位是 $6$，那么有 $f_{i,3}&#x3D;f_{i-1,3}+1,f_{i,4}&#x3D;f_{i-1,4}+1$。区间询问使用广义矩乘做就行，可以倍增做。复杂度 $\Theta(nk^3 \log n)$，其中 $k&#x3D;5$。</p>
<h3 id="CF763E"><a href="#CF763E" class="headerlink" title="CF763E"></a>CF763E</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF763E">题目链接</a></p>
<p>跟 CF811E 类似，由于一个点只会连与它距离不超过 $k$ 的点，所以如果一个联通块最左、最右是 $l,r$，并且 $[l-k,l-1],[r+1,r+k]$ 都没有跟这个联通块相连的，那么再往外就不可能有与它相连的了。所以也考虑线段树维护 $[l,r]$，记录 $[l,r]$ 的联通块个数，并且维护 $[l,l+k-1],[r-k+1,r]$ 每个点所在的联通块。合并直接开个 $4k$ 大小空间的并查集合并这些点就好了，注意区间小的时候还要更新左边和右边的 $k$ 个点。复杂度 $\Theta(nk^2 \log n)$​。</p>
<h3 id="CF848C"><a href="#CF848C" class="headerlink" title="CF848C"></a>CF848C</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF848C">题目链接</a></p>
<p>套路地将最后一次出现的下标描述成 $nxt_i &gt;r$ 的 $i$。那么答案就是 $\sum\limits_{i&#x3D;l}^r i[nxt_i &gt; r]-\sum\limits_{i&#x3D;l}^r i[pre_i &lt; l]$。那么考虑一个 $(i,nxt_i)$，将 $[1,i][i,nxt_i - 1]$ 区间加上 $i$，把 $(i,pre_i)$ 的 $[pre_i + 1,i][i,n]$ 矩阵减去 $i$。再开 $\Theta(V)$ 个 set 维护每个值出现位置，每次单点修改只用更新 $\Theta(1)$ 个值。所以就要支持矩阵加，单点求值。在线就可以树套树，离线可以 cdq 三维数点。复杂度 $\Theta(n\log^2 n)$。	</p>
<h3 id="CF1004F"><a href="#CF1004F" class="headerlink" title="CF1004F"></a>CF1004F</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1004F">题目链接</a></p>
<p>经典 trick 是前缀或和不超过 $\log V$ 段。所以线段树上直接维护被完全包含在当前区间的答案和前缀、后缀的或和 <strong>段</strong>。合并的时候，后缀从右边继承，再接上左边，前缀同理。答案是左边加上右边，然后再做个双指针，左边从 $mid$ 往左扫，右边从 $mid+1$ 往右扫即可，合并复杂度 $\Theta(\log V)$。单点改就直接改。所以总复杂度就说 $\Theta(n\log n \log V)$。</p>
<h3 id="CF1140F"><a href="#CF1140F" class="headerlink" title="CF1140F"></a>CF1140F</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1140F">题目链接</a></p>
<p>注意到满足要求的肯定是一个缺一个角的矩形，补上去会形成一个完整的矩形。然后再考虑一直这样做最后会形成什么，就是会形成一堆矩形，且它们的行列都是不同的。这启发我们找一个联通块，然后就会注意到如果对于每个点，把它的行列连边，最后得出来的每个联通块就会形成一堆矩形。考虑线段树分治，并查集维护连通性和行列数量即可。复杂度 $\Theta(n\log^2 n)$。</p>
<h3 id="CF1316F"><a href="#CF1316F" class="headerlink" title="CF1316F"></a>CF1316F</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1316F">题目链接</a></p>
<p>即求每个子序列的代价和，考虑对每个相邻点对 $(a_i, a_{i+1})$ 求贡献。考虑线段树维护值域，对每个区间 $[l,r]$ 记录只保留值在 $[l,r]$ 的点的所有点对值乘方案的和，每个点的 $p_i \times 2^{L_i}$ ，$L_i$ 为 $i$ 左边的点数，和 $p_i \times 2^{R_i}$，记作 $suml,sumr$，还有区间中的点数 $cnt$ 。合并时，$ans&#x3D;ans_{ls} \times 2^{cnt_{rs}} + ans_{rs} \times 2^{cnt_{ls}}+suml_{ls} \times sumr_{rs}$，$suml &#x3D; suml_{ls} +suml_{rs}\times 2^{cnt_{ls}},sumr&#x3D;sumr_{ls} \times 2^{cnt_{rs}} + sumr_{rs},cnt&#x3D;cnt_{ls}+cnt_{rs}$。 因为有重复的值，所以对所有可能出现的数排序放到下标就行。复杂度 $\Theta(n\log n)$。</p>
<h3 id="CF1371F"><a href="#CF1371F" class="headerlink" title="CF1371F"></a>CF1371F</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1371F">题目链接</a></p>
<p>考虑线段树维护每个区间正着和反着的信息。考虑答案需要记录什么，要知道从一端走能到达哪里，要知道两端溢出了多少球。于是线段树记录 $ans,tL,tR,L,R$ 分别表示此区间的答案，左边溢出的球，右边溢出的球，（从左边加球能到达的位置，那个位置的球数量），右边同理。转移是简单的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c.tL = (R.se == l ? tL + b.tL : tL), c.tR = (b.L.se == b.r + 1 ? b.tR + tR : b.tR);</span><br><span class="line">c.L = (L.se == b.l ? make_pair(tR + b.L.fi, b.L.se) : make_pair(L.fi + (R.se == L.se ? b.tL : 0), L.se));</span><br><span class="line">c.R = (b.R.se == b.l ? make_pair(b.tL + R.fi, R.se) : make_pair(b.R.fi + (b.R.se == b.L.se ? tR : 0), b.R.se));</span><br><span class="line">c.l = l, c.r = b.r;</span><br></pre></td></tr></table></figure>

<p>区间取反直接打标记，交换正反信息即可。复杂度 $\Theta(n\log n)$。</p>
<h3 id="CF1373G"><a href="#CF1373G" class="headerlink" title="CF1373G"></a>CF1373G</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1373G">题目链接</a></p>
<p>一个点如果一直往第 $k$ 行走，设它最前能到达的格子为 $x$，那么它可以被放到 $[x,n]$ 这些格子里。那么要把一堆点都能放完的话，设 $suf_i$ 为 $[i,n]$ 有多少个 $x$，条件就是 $\forall i,suf_i \le m-i+1$ 即 $suf_i + i - 1\le m$，最小的 $m$ 即 $suf_i + i - 1$ 的最大值。</p>
<p>考虑动态修改，使用线段树维护，每次插入一个 $x$ 把 $[1,x]$ 加 $1$，删除减 $1$，查全局最大即可。复杂度 $\Theta(n\log n)$。</p>
<h3 id="CF1379F2"><a href="#CF1379F2" class="headerlink" title="CF1379F2"></a>CF1379F2</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1379F2">题目链接</a></p>
<p>考虑相邻两行，注意到每相邻两行 $(2x+1,2x+2)$ 直接最多只能放 $m$ 个，又因为只有 $2n$ 行，所以每相邻两行必须放 $m$ 个。显然，这 $m$ 个如果能放到 $2x+1$ 这行肯定最优，否则就是 $2x+1$ 这行有个地方挡住了，只能放到 $2x+2$ 行，那么上面就是一个前缀，下面就是一个后缀，分别对应 $1$ 到 $2x+1$ 这行第一个空缺的位置 $x$，$2x+2$ 行最后一个空缺的位置 $y$ 到 $2m$，所以这里要求 $x&gt; y$，设上面那行是在第 $t$ 个放完后终止的，那么 $t\in [\dfrac{y}{2},\dfrac{x-1}{2}]$。并且要求 $\forall i,t_i \ge t_{i+1}$。</p>
<p>问题转化为，给定 $n$ 个区间，动态修改区间，要求在每个区间中取一个数，且这个数不能大于上次取的。由于拓展区间不好做，不妨使用线段树分治把动态修改区间改为动态缩减区间。贪心的想法是每个区间尽量往右取，那么每取完一个 $x$ 就直接对后面所有区间的 $r$ 对 $x$ 取 $\min$ 即可，如果碰到一个 $l&gt;r$ 就是不合法的了。</p>
<p>复杂度 $\Theta(n\log^2 n)$。</p>
<h3 id="CF1439C"><a href="#CF1439C" class="headerlink" title="CF1439C"></a>CF1439C</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1439C">题目链接</a></p>
<p>看到形如 $y \ge a_i,y\to y-a_i$ 的形态，第一时间想倍增分块。注意到这个 $a$ 无论何时都是不增的，这也就避免了倍增分块中要考虑 $&lt;2^k$ 的和的情况。</p>
<p>那么现在思路就明确了，若现在在 $x$，设能连续取的极长长度为 $len$，也就是能连续取完 $[x,x+len-1]$。若 $len &lt; n-x+1$，那么 $y$ 必定会减半，因为若不减半，最后一个取的一定小于 $\dfrac{y}{2}$，后一个依然小于 $\dfrac{y}{2}$，那么显然可以再取一个。</p>
<p>考虑怎么跳，显然直接在线段树上二分找到下一个位置即可。考虑修改，如果直接吉司机当然可以，但是每必要，也是直接二分找到第一个 $&lt;y$ 的位置即可。</p>
<p>复杂度 $\Theta(n\log n \log V)$。</p>
<h3 id="CF1386C"><a href="#CF1386C" class="headerlink" title="CF1386C"></a>CF1386C</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1386C">题目链接</a></p>
<p>首先观察奇环怎么处理，只需要找到一棵生成树然后对于每个非树边看看和树边形成的环是否为奇环即可，可以使用带权并查集维护。具体地，当连接一条边时，由于并查集上的边不是真实的边，所以找到 $(x,y)$ 到 $(rt_x,rt_y)$ 的边权异或和，将其异或 $1$ 然后作为 $(rt_x,rt_y)$ 的边权。每次查询 $(x,y)$ 直接找到 $(x,y)$ 到根的边权异或和异或起来是 $0$ 即可。</p>
<ul>
<li>解法一 $\Theta(n\sqrt{n})&#x2F;\Theta(n\sqrt{n}\log n)$</li>
</ul>
<p>考虑把边的序列复杂一边接到后面，然后每次询问就是用一个区间的边。使用不删除莫队，直接维护即可。复杂度可能带个 $\log$，由于要撤销并查集，不能使用路径压缩。</p>
<ul>
<li>解法二 $\Theta(n\log n)&#x2F;\Theta(n\log^2 n)$</li>
</ul>
<p>考虑令 $nxt_i$ 为以 $i$ 作为左端点，最远的 $r$ 使得删掉 $[i,r]$ 这段区间还有奇环。显然 $nxt_i$ 是随 $i$ 单调不降的。考虑使用分治优化决策单调性，设 $f(l,r,L,R)$ 为处理 $[l,r]$ 的 $nxt$，并且值域（即决策点）在 $[L,R]$ 范围内。递归到 $f(l,r,L,R)$ 时，应先加入所有除了 $[l,R]$ 的边，然后令 $mid &#x3D; \lfloor\dfrac{l+r}{2}\rfloor$，考虑从 $R$ 往 $L$ 依次加入每条边，一旦有奇环那么 $nxt_{mid}$ 就设为当前枚举的边。然后就递归地调用 $f(l,mid-1,L,nxt_{mid})$，注意此时<strong>不需要</strong>撤销 $[nxt_{mid}+1,R]$ 的边。然后处理完左边后撤销掉 $[nxt_{mid} + 1,R]$ 的边，加入 $[l,mid]$ 的边，再做 $f(mid+1,r,nxt_{mid},R)$。返回的时候再撤销掉即可。复杂度也会多个 $\log n$，因为并查集。</p>
<h3 id="CF1442D"><a href="#CF1442D" class="headerlink" title="CF1442D"></a>CF1442D</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1442D">题目链接</a></p>
<p>先观察一下最后答案长什么样，发现一定是一堆整串再加上至多一个前缀。因为若有两个前缀，可以考虑把下一个数较大的前缀往后取一位，另一个最后删一位，一定是更优的。所以问题转化为有 $n$ 个物品，每个重量 $len_i$，价值 $sum_i$，且能额外取一个前缀，要求取的重量不超过 $n$。</p>
<p>朴素的想法是枚举那个前缀在的串，然后其他的用个背包，但因为是最优化，所以不能可撤销背包来搞。既然不能直接删除一个物品，那么考虑不用删除物品的<strong>分治</strong>。当在做 $f(l,r)$ 的时候，若下一步做 $f(l,mid)$，那么先把当前的背包值记录下来，然后加入 $[mid+1,r]$ 这些物品，再递归下去。返回的时候还原之前记录的背包数组，然后加入 $[l,mid]$，再做右边 $f(mid+1,r)$。这样的话一个节点的复杂度是 $\Theta(len\cdot k)$。</p>
<p>总复杂度为 $\Theta(nk\log n)$。</p>
<h3 id="CF1648D"><a href="#CF1648D" class="headerlink" title="CF1648D"></a>CF1648D</h3><p>考虑一个朴素 dp，设 $f_i$ 为走到 $(2,i)$ 的最大价值，$sum_i$ 为第二行的前缀和，$a_i$ 为第一行的前缀和，$b_i$ 为第三行的后缀和。转移有 $f_i &#x3D; sum_i + \max\limits_{j&lt;i}(\max(f_j-sum_{j},a_j-sum_{j-1}) -\min\limits_{l_x \le j \le r_x} k_x)$ 。重点在于 $-\min\limits_{l_x \le j \le r_x} k_x$。</p>
<p>考虑分治，用 cdq 的思想，先把左边的 $f$ 处理出来，然后通过 $j\in [l,mid]$ 去更新 $i\in [mid+1,r]$，先对左边 $[l,mid]$ 记录后缀最大 $suf_i &#x3D; \max\limits_{j&#x3D;i}^{mid} \max(f_j-sum_{j},a_j-sum_{j-1})$。考虑把 $(l,r,k)$ 分为两种。</p>
<ul>
<li>$r_x \in [mid+1,r]$ 那么可以对 $i\in [mid+1,r_x]$ 的 $f_i$ 对 $suf_{\max(l_x,l)} - k_x$ 取最大。由于每个这样的 $(l,r,k)$ 只会出现 $\Theta(\log n)$ 次，复杂度 $\Theta((n+q)\log n)$。</li>
<li>$r_x&gt;r$ 那么这样的 $(l,r,k)$ 一定是在当前节点的祖先是出现在第一种的，并且是递归到了左边。那么考虑在那个祖先的地方递归到左边的时候在 $l_x$ 处插入一个 $k$。<ul>
<li>若 $l_x \ge l$ 在做 $suf_i$ 的是时候直接找到 $[l,i]$ 中最小的 $k_x$ 即可，用它更新所有 $[mid+1,r]$。</li>
<li>否则的话一定是上面那种递归到右端点的，这时候的分治区间被 $[l_x,r_x]$ 完全包含，所以记录最小那个即可。</li>
</ul>
</li>
</ul>
<p>总复杂度为 $\Theta((n+q)\log n)$。</p>
<h3 id="CF1654F"><a href="#CF1654F" class="headerlink" title="CF1654F"></a>CF1654F</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1654F">题目链接</a></p>
<p>考虑异或的性质，若第 $i$ 位为 $1$，那么就是将原序列以 $2^{i-1}$ 为一块分成若干块，奇数块和偶数块交换。设 $f(x,i)$ 为异或 $x$ 形成的新序列的前 $2^i$ 个形成的序列，那么显然 $f(x,i)&#x3D;f(x,i-1)+f(x\oplus 2^{i-1},i-1)$。设 $g(x,i)$ 为异或 $x$ 形成的新序列的前 $2^i$ 个数在异或 $[0,2^n -1]$ 形成的所有新序列中的排名，那么直接以 $(g(x,i-1),g(x\oplus 2^{i-1},i-1))$ 为关键字排序即可得到 $g(x,i)$。复杂度 $\Theta(n\log^2 n)$。</p>
<h3 id="CF1693D"><a href="#CF1693D" class="headerlink" title="CF1693D"></a>CF1693D</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1693D">题目链接</a></p>
<p>首先观察一下，发现无解的充要条件是存在一个四元组 $(a,b,c,d)$ 满足 $a&lt;b&lt;c&lt;d$ 使得 $p_b &gt; p_a &gt; p_d &gt; p_c$ 或 $p_c &gt; p_d &gt; p_a &gt; p_b$。因为这两种形态满足它们都是两个上升或下降子序列组成的且都不相交。然后考虑统计，设 $pre_i$ 为 $i$ 之前最大的 $j$ 满足区间 $[j,i]$ 无解，考虑第二种形态，设 $L_i$ 为 $i$ 前面第一个大于 $p_i$ 的点，$R_i$ 为 $i$ 后面第一个小于 $p_i$ 的点。所以 $pre_i$ 就是最大的 $j$ 满足 $R_j &lt; L_i,p_j&lt;p_i$，直接二维偏序，bit 维护即可。第一种形态可以直接把序列变成 $n-p_i + 1$ 再做一遍就行。复杂度 $\Theta(n\log n)$。</p>
<h3 id="CF1730E"><a href="#CF1730E" class="headerlink" title="CF1730E"></a>CF1730E</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1730E">题目链接</a></p>
<p>先预处理每个位置是最大值的区间 $[L_i,R_i]$ 满足 $\forall j \in [L_i,i-1],a_j &lt; a_i \land \forall j\in [i+1,R_i],a_j \le a_i$，再预处理每个数前面第一个比它小的和后面第一个比它小的位置 $pre_i,suf_i$，可以单调栈 $\Theta(n)$ 预处理。</p>
<p>考虑枚举最大值的位置 $i$，枚举 $a_i$ 的因数 $x$。找到 $i$ 前面 $x$ 第一个出现的位置 $lst$ 和 $i$ 后面第一次出现的位置 $nxt$。讨论 $[lst,i]$ 和 $[i,nxt]$ 是否最小值是 $x$。若 $[lst,i]$ 最小值为 $x$，那左端点可以取到 $[\max(L_i,pre_{lst}),lst]$，否则若 $[i,nxt]$ 最小值是 $x$，那么左端点可以取到 $(suf_{lst},i]$，右端点可以取到 $[nxt,\min(R_i,suf_{nxt})]$。右边同理。若 $lst$ 不存在，左端点可以取到 $[pre_{nxt},i]$，右端点同上。$nxt$ 不存在同理。</p>
<p>设值域为 $m$，复杂度 $\Theta(m\log m + nd(m))$。</p>
<h1 id="位问题"><a href="#位问题" class="headerlink" title="位问题"></a>位问题</h1><h3 id="CF241B"><a href="#CF241B" class="headerlink" title="CF241B"></a>CF241B</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF241B">题目链接</a></p>
<p>考虑先找到第 $m$ 大的两两异或值。二分答案 $x$，然后对每个数 $a_i$ 找到所有 $j&lt;i,a_i\oplus a_j \le x$ 的 $(i,j)$ 对数，可以用 trie 实现，这部分复杂度 $\Theta(n\log^2 a)$。</p>
<p>然后可以先找到前 $m$ 大有多少个 $x$，可以用 $m$ 减去异或和 $\le x-1$ 的对数得到。那么就是求 $\sum\limits_{i&#x3D;1}^n \sum\limits_{j&#x3D;1}^{i-1} [a_i \oplus a_j &lt; x] (a_i \oplus a_j)$。也可以用 trie 实现，查询 $i$ 时，可以先找到 trie 上哪些子树里的数是合法的，然后拆位算贡献，对于 trie 上每个节点记录它子树中第 $j$ 位是 $0&#x2F;1$ 的数的个数，异或上 $x$ 对应位即可。复杂度也是 $\Theta(n\log^2 a)$。</p>
<p>总复杂度 $\Theta(n\log^2 a)$。</p>
<h3 id="CF633G"><a href="#CF633G" class="headerlink" title="CF633G"></a>CF633G</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF633G">题目链接</a></p>
<p>注意到 $m$ 很小，可以对每个点记录子树中每个值的出现情况。设 $f_{i,j}$ 表示值 $j$ 是否在 $i$ 子树中出现，对 $i$ 子树加 $v$ 相当于将其向右循环移位 $v$ 次。但是由于子树加 $v$ 还会影响祖先的 $f$ 值，所以不能这样维护。</p>
<p>考虑换种方式，查的时候直接将子树里的值或起来就行。使用线段树 + dfn 序列维护，每次相当于区间循环移位，区间求或，可以套个 bitset，复杂度 $\Theta(\dfrac{m(n+q\log n)}{w})$。</p>
<h3 id="CF796F"><a href="#CF796F" class="headerlink" title="CF796F"></a>CF796F</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF796F">题目链接</a></p>
<p>考虑操作 $1$。</p>
<ul>
<li>若 $[l,r]$ 中已确定的最大值为 $x$，则表示剩下的区间中的每个数都小于等于 $x$。</li>
<li>若 $[l,r]$ 中已确定的都小于 $x$，那么剩下的区间中每个数都小于等于 $x$，且存在一个数为 $x$。</li>
</ul>
<p>现在问题转化为，给定若干个限制（可能达到 $\Theta(n^2)$ 级别）表示一个区间的数小于等于一个数，或者一个区间的数小于等于一个数且存在一个数等于。那么按照 $x$ 从小到大排序，显然只用考虑所有之前没覆盖的位置，如果是第二种限制，那就先随便钦定一个位置为 $x$，若还有剩下位置没钦定，那么设之前自己确定的所有位置或和为 $sum$，从高到低枚举每个位置，若 $sum$ 这个位置为 $0$ 且加上后不超过 $x$ 就加上，显然最多确定两个数就能到达目前的最优了。</p>
<p>那么还有一个问题，就是限制是 $\Theta(n^2)$ 级别的，该如何优化？注意到每次操作只会改一个点，那么处理出来每个点什么时候第一次被改即可，套上个线段树分治，每次直接找每个包含 $t$ 的在 $[l,r]$ 中的点删掉即可。</p>
<p>复杂度 $\Theta(n\log^2 n)$。</p>
<h3 id="CF1511G"><a href="#CF1511G" class="headerlink" title="CF1511G"></a>CF1511G</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1511G">题目链接</a></p>
<p>题目就是要求 $\oplus_{i&#x3D;l}^r (a_i - l)$，$a_i$ 是值是 $i$ 的所有数异或和。考虑倍增，设 $f_{i,j}$ 为 $l&#x3D;i$ 时 $[i,i+2^{j} -1]$ 区间的异或和，此时这个区间里所有数减 $i$ 的第 $j$ 位都必定是 $0$。那么转移的时候，由于 $[i+2^{j-1},i+2^j - 1]$ 这段区间减 $i+2^{j-1}$ 的第 $j-1$ 位也是，所以可以直接异或上 $2^{j-1}cnt_{i+2^{j-1},i+2^j-1}$，即 $f_{i,j}&#x3D;f_{i,j-1}\oplus f_{i+2^{j-1},j-1}\oplus (2^{j-1}\times (cnt_{i+2^{j-1},i+2^j - 1} \operatorname{mod} 2))$。 </p>
<p>回答询问也是类似搞即可。复杂度 $\Theta((m+q)\log m)$。</p>
<h3 id="CF1730F"><a href="#CF1730F" class="headerlink" title="CF1730F"></a>CF1730F</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1730F">题目链接</a></p>
<p>先求出 $p$ 的逆排列 $pos$，然后就是把每个数 $i$ 填到 $p$ 里面，满足 $i$ 出现在 $j$ 前面时 $i \le j+k$，求 $pos_i$ 的逆序对最大。</p>
<blockquote>
<p>对于任意的 $i$，$q$ 前 $i$ 个数中所有 $\le i-k$ 的数都必须存在。</p>
</blockquote>
<p>证明：若存在 $x\le i-k$ 且 $x$ 不在 $q$ 中前 $i$ 个数，则 $q$ 中前 $i$ 个数的最大值 $t \ge i+1$，由于 $x$ 不在前 $i$ 个中，所以 $t\le x + k \le i$，又因为 $t\ge i+1$，故矛盾。</p>
<blockquote>
<p>对于任意的 $i$，$q$ 前 $i$ 个数中所有 $&gt;i+k$ 的数都不能存在。</p>
</blockquote>
<p>证明：若存在 $x&gt;i+k$ 在 $q$ 前 $i$ 个数中，则 $q$ 中前 $i$ 个数中第一个没出现的数 $t \le i$，由于 $x$ 在 $t$ 前面，所以 $x\le t+k$，即 $t&gt;i$，矛盾。</p>
<p>那么可以得出前 $i$ 个数中不确定是否存在的数只有 $[i-k+1,i+k]$ 这 $2k$ 个。</p>
<blockquote>
<p>对于任意的 $i$，$q$ 前 $i$ 个数肯定是一段连续的值域再加上 $[i+1,i+k+1]$ 的某些数</p>
</blockquote>
<p>这是显然的。</p>
<p>设 $f_{i,j}$ 为加入了前 $[1,i]$ 这些数，$[i+1,i+k+1]$ 的出现情况是 $j$ 的最小逆序对个数，枚举转移即可。复杂度 $\Theta(n^2 + nk2^k)$。</p>
<h1 id="贪心问题"><a href="#贪心问题" class="headerlink" title="贪心问题"></a>贪心问题</h1><h3 id="CF30E"><a href="#CF30E" class="headerlink" title="CF30E"></a>CF30E</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF30E">题目链接</a></p>
<p>考虑对一个 $a’$ 找到其对于的 $a$，肯定是越前越优，那么拿 $S$ 的反串做个 kmp 即可得到每个 $a$ 的第一次出现位置。然后就是在区间中找最长的奇回文串，manacher 预处理，然后二分半径 $len$，看看 $[l+len-1,r-len+1]$ 是否存在 $p_i \ge len$ 即可，st 表维护。复杂度 $\Theta(n\log n)$。</p>
<h3 id="CF187E"><a href="#CF187E" class="headerlink" title="CF187E"></a>CF187E</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF187E">题目链接</a></p>
<p>特判 $l&#x3D;0,1$。</p>
<p>由于最左、最右都要去，所以答案有个明显的下界是 $\min(x_s -x_1,x_n - x_s)+x_n-x_1$。假设取到 $x_s-x_1$（可以翻转再做一遍），那么最优肯定是要从 $s$ 先往左走到 $1$，然后跳到 $s+1$ 再一直往右走到 $n$，但会出现左票不足或过多的情况。</p>
<ul>
<li>左票不足：那就是先往左走几步，然后跳到 $1$，往右走回来的时候再走那些没走过的。</li>
<li>左票太多：那就是 $[s+1,n]$ 这些位置有些要通过左票到达，那一个点在 $s$ 右边且被左票到达肯定是往右走到了某个点然后往回走到了它，这时有可能是从 $n$ 往回走的，那么 $[x_i,x_{i+1}]$ 这段区间只用走 $2$ 次，否则就要走 $3$ 次，那么枚举终点在哪里，找到 $s$ 到终点这段区间中前 $k$ 小的区间换成左票即可，$k$ 是左票剩的减去从 $n$ 走回终点的。</li>
</ul>
<p>可以用平衡树或线段树维护前 $k$ 小，复杂度 $\Theta(n\log n)$​。</p>
<h3 id="CF196D"><a href="#CF196D" class="headerlink" title="CF196D"></a>CF196D</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF196D">题目链接</a></p>
<p>考虑找到原串最大位置 $pos$ 使得 $s[1,pos]$ 没有长度大于等于 $d$ 的回文子串，然后从 $pos$ 开始尝试替换。注意到只用考虑长度为 $d,d+1$ 的回文串，因为 $d+2,d+3$ 的包含 $d,d+1$ 的。如果 $pos$ 往前某个位置替换成一个字符后，以它结尾的 $d,d+1$ 的串都不是回文串，那就开始往后加字符，直接暴力枚举判断是否合法即可。复杂度 $\Theta(nc)$​。</p>
<h3 id="CF436E"><a href="#CF436E" class="headerlink" title="CF436E"></a>CF436E</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF436E">题目链接</a></p>
<p>考虑反悔贪心，每次添加一个星星，有几种情况。</p>
<ul>
<li>从选了一个的加上 $b_i- a_i$</li>
<li>从没选的加上 $a_i$</li>
<li>从选了一个的和没选的加上 $-a_i + b_j$</li>
<li>从选了两个的和没选的加上 $a_i - b_i + b_j$</li>
</ul>
<p>用五个堆维护最小的 $a_i,b_i,-a_i,a_i - b_i,b_i - a_i$ 即可，复杂度 $\Theta(n\log n)$。</p>
<h3 id="CF524F"><a href="#CF524F" class="headerlink" title="CF524F"></a>CF524F</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF524F">题目链接</a></p>
<p>设 $cnt0,cnt1$ 为删掉原括号串的所以合法括号子序列后的 $($ 和 $)$ 的个数，显然最少添加 $|cnt0-cnt1|$ 个括号。考虑操作 $2$，就是要求一个字典序最小的循环同构，使得这个循环同构也只需要 $|cnt0-cnt1|$ 个括号，先不管原串中所有没匹配的字符，这个循环同构的起点一定是原串某个合法括号子段的开头，枚举这个位置，再看看这样循环移位后原来没匹配的那些字符还需要添加多少个，若为 $|cnt0-cnt1|$，那么这个位置就是可能可行的。</p>
<p>考虑所有可行的位置，要找到字典序最小那个，就把原串复制一遍接到后面，然后后缀排序即可。使用 SA 常数较大，可能无法通过，使用 SAM 可以做到 $\Theta(n)$。</p>
<p>复杂度 $\Theta(n)$ 或 $\Theta(n\log n)$。</p>
<h3 id="CF625E"><a href="#CF625E" class="headerlink" title="CF625E"></a>CF625E</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF625E">题目链接</a></p>
<p>按照位置排序后显然每个没被删掉的人相对位置不会改变，可以用链表维护这个相对位置。然后每个人先删的肯定是它下一个人，那就对每个人维护删掉它后一个人至少需要多少轮，把它放进一个小根堆里面，每次取出堆顶的人，记录时间 $t$，从它开始一直往后删，直到需要的时间大于 $t$ 停止，记录被删的人数。每次把所有 $t$ 相同的人拿出来，这样更新后，更新它们的速度，并且记录每个人上次更新速度的时间（用现在的时间减去上次更新的时间乘上速度就是当前的位置）。然后再对这一轮 $t$ 相等的人找到它们上一个人和下一个人，更新删掉它或删掉其他人的时间，继续放到堆里面。模拟这个过程即可，复杂度 $\Theta(n\log n)$。</p>
<h3 id="CF671D"><a href="#CF671D" class="headerlink" title="CF671D"></a>CF671D</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF671D">题目链接</a></p>
<p>考虑权值都是 $1$ 怎么做，显然从深的往浅的遍历每条边，如果遇到一条边没被覆盖，就找到能覆盖到这条边的且 $y$ 最浅的那条边选择。</p>
<p>考虑权值任意，此时依然从深往浅做，并且每次取权值最小的那条路径。当然，直接这样是显然错误的，因为权值小的路径深度可能不如权值大的浅。那么就可以考虑一个反悔贪心的过程，每次依然贪心地选择权值最小的，并且把 $x$ 在这个权值最小的路径的 $x$ 下方或等于它的所有路径的 $x$ 设为这条路径的 $y$，把它们的权值减去当前选的这条路径。</p>
<p>实现可以考虑从下往上合并，并且记录还能往上覆盖几条边和下方的所有没被选的且 $y$ 在这个点上方的路径，还要支持单点修改和整体减。可以考虑线段树合并或平衡树来维护这个东西。复杂度 $\Theta(n\log n)$ 或 $\Theta(n\log^2 n)$。</p>
<h3 id="CF797F"><a href="#CF797F" class="headerlink" title="CF797F"></a>CF797F</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF797F">题目链接</a></p>
<p>注意到把老鼠和洞按照编号排序，每个洞进的老鼠一定是一段连续的区间，设 $dp_{i,j}$ 表示前 $i$ 个洞进了前 $j$ 个老鼠，设 $sum_{i,j}$ 为洞 $i$ 到前 $j$ 个老鼠的距离和，转移有 $dp_{i,j} &#x3D; \max\limits_{k&#x3D;\max(0,j-c_i)}^{j} dp_{i-1,k}+sum_i - sum_k$，显然可以单调队列优化。</p>
<p>复杂度 $\Theta(nm)$。</p>
<h3 id="CF935F"><a href="#CF935F" class="headerlink" title="CF935F"></a>CF935F</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF935F">题目链接</a></p>
<p>这里设 $a_i$ 为原来的 $a_i - a_{i-1}$，那么 $f(a)&#x3D;\sum\limits_{i&#x3D;2}^n |a_i|$。</p>
<p>考虑操作 $1$，特判边界。即在 $a_l$ 到 $a_r$ 中选一个 $a_i \leftarrow a_i + x,a_{i+1} \leftarrow a_{i+1} -x$。讨论一下有哪些情况，设 $ans$ 为选择一个位置加上 $x$ 后和原序列答案的差。</p>
<ul>
<li>$r-l+1\le 3$，直接暴力跑一下</li>
<li>$\exist i,a_i \ge 0,a_{i+1} \le 0$，则 $ans&#x3D;2x$，是最优的情况。</li>
<li>$\exist i,a_i \ge 0,a_{i+1} \ge 0$，可以发现 $ans$ 总非负。<ul>
<li>$a_{i+1} \le x$，则 $ans &#x3D; 2(x-a_{i+1}) $。</li>
<li>$a_{i+1} \ge x$，则 $ans&#x3D;0$。</li>
</ul>
</li>
<li>$\exist i,a_i \le 0,a_{i+1}\le 0$，可以发现 $ans$ 总非负。<ul>
<li>$a_{i} \ge -x$，则 $ans &#x3D; 2(x+a_i)$。</li>
<li>$a_{i} \le -x$，则 $ans&#x3D;0$。</li>
</ul>
</li>
<li>$\exist i,a_i \le 0,a_{i+1} \ge 0$，可以发现只要 $a_i \le -x \lor a_{i+1} \ge x$，那么 $ans$ 一定非正，所以只用考虑 $a_i \ge -x \land a_{i+1}\le x$，此时 $ans&#x3D;2x + 2(a_i - a_{i+1})$。</li>
</ul>
<p>综上，当长度大于 $3$ 时，必定出现正负或正正或负负，$ans$ 一定非负，只需要维护所有满足条件的 $-a_{i+1},a_i,a_i - a_{i+1}$ 的最大值即可，用线段树维护，复杂度 $\Theta(n\log n)$。</p>
<h3 id="CF1051G"><a href="#CF1051G" class="headerlink" title="CF1051G"></a>CF1051G</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1051G">题目链接</a></p>
<p>考虑单个序列怎么做，因为把一个数变少可以得到 $-b_i$ 的价值，那先尽可能地减少一定是不劣的。如果有若干个相同的 $a_i$，那么肯定是最后让 $b$ 最小的 $a$ 最大，$b$ 最大的 $a$ 最小，这是容易的。但是整个序列有可能不能都变成同一种值，会分成若干段，每个极长段的形成是先把小的数变大，形成一个区间，被这个区间包含的数继续拓展这个区间，直到不能拓展为止。统计的话是容易的。</p>
<p>考虑对每个前缀求答案，那可以维护前面的若干值域连续段，显然加一个数最多添加一个段，有可能合并两个段。一个段内肯定是先把所有数变成这个段里的最小值，然后把它们的 $b$ 排序，代价就是 $-\sum\limits_i (a_i -minx)b_i+\sum\limits_i b_i(len-rk_i)$ 即 $-\sum\limits_{i} (a_i - minx+rk_i)b_i+len\sum\limits_i b_i$。$rk_i$ 的处理可以用线段树合并来做。复杂度 $\Theta(n\log n)$。</p>
<h3 id="CF1137E"><a href="#CF1137E" class="headerlink" title="CF1137E"></a>CF1137E</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1137E">题目链接</a></p>
<p>显然只用管每次插入的第一个数，且每次进行操作 $1$ 之后只用考虑第一段的第一个数。当进行操作 $2$ 的时候，会暂时性地使最小值变成最后一段的第一个，但是这个影响会随操作 $3$ 而逐渐消去，因为最后一段的下标大。</p>
<p>考虑维护一个不增的结构，对于相邻的两个下标 $(x,y)$，每次进行操作 $3$ 会使 $a_x - a_y$ 减少 $s(y-x)$，而 $x,y$ 是固定的（因为操作 $1$ 之后会把整个结构清空），所以记录 $t_x &#x3D; \lceil \dfrac{a_x - a_y}{y-x} \rceil$ 表示 $s$ 至少为 $t_x$ 时 $a_x$ 会比 $a_y$ 小。用链表+小根堆维护这个结构，每次往后插入后在链表最后插入一个 $0$，并把倒数两个的 $t_x$ 插入到堆里面。每次进行操作 $3$ 时看看堆顶是否已经足够了，就将其删除。操作 $1$ 直接情况即可。复杂度 $\Theta(n\log n)$。</p>
<h3 id="CF1238G"><a href="#CF1238G" class="headerlink" title="CF1238G"></a>CF1238G</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1238G">题目链接</a></p>
<p>考虑将所有人按照时间排序，到时间 $i$ 时先把能买的都买了，先不付款，每次从 $lst$ 走到时间 $i$ 时，取前 $i-lst$ 小的付款。但是会有容量限制，不能无限制地买，那么买 $i$ 时如果已经满了，可以把前面还没用到的价格比 $i$ 大的取消购买，反悔贪心。注意到每次从一个人走到下一个人要么只买以前一个人的，要么就至少买空一个人，所以一共只会买 $\Theta(n)$ 段相同的。用堆维护价格最小值和最大值，并用一个数组记录每个人能用的有多少即可。复杂度 $\Theta(n \log n)$​。</p>
<h3 id="CF1446D2"><a href="#CF1446D2" class="headerlink" title="CF1446D2"></a>CF1446D2</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1446D2">题目链接</a></p>
<p>注意到所有极长的拥有 $2$ 个以上众数的段一定以全局众数为众数之一。证明：若全局众数不为其众数，可以拓展左右端点直到全局众数的出现次数等于其众数的出现次数。那么如果全局众数有不止 $1$ 个，答案即为 $n$，否则设其为 $x$。考虑答案子区间的众数出现次数 $cnt$。</p>
<ul>
<li>若 $cnt&gt;B$，只用考虑所有出现次数 $&gt;B$ 的数，有 $\Theta(\dfrac{n}{B})$ 个，考虑枚举这些数 $i$，把 $x$ 设为 $1$，$i$ 设为 $-1$，找到一个极长的段使得和等于 $0$ 即可，用一个桶记录前缀和第一次出现位置，复杂度 $\Theta(\dfrac{n^2}{B})$。</li>
<li>若 $cnt \le B$，考虑枚举这个出现次数 $i$。从左往右枚举答案的右端点 $r$，双指针记录 $x$ 出现次数为 $i$ 的合法做端点 $l$ 的区间，对于其他数也这样做，最小的 $l$ 就是所有其他数的 $l$ 区间和 $x$ 的 $l$ 区间交的最小值。复杂度 $\Theta(nB)$。</li>
</ul>
<p>复杂度 $\Theta(n\sqrt{n})$。</p>
<h3 id="CF1469F"><a href="#CF1469F" class="headerlink" title="CF1469F"></a>CF1469F</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1469F">题目链接</a></p>
<p>考虑二分答案，然后按长度从大到小排序，依次从浅到深加入，每次加入一条链时尽量把连接点放到中心。每次连接中心是显然的，因为让 $\le mid$ 的白点尽可能浅来接其他链。从大到小加入是因为每次链接的上面那个白点的深度是单调不降的，所以肯定让深度浅的时候能贡献更多，如果在深一点的地方接大的就会造成浪费了。差分维护一下即可，复杂度 $\Theta(n\log n)$。</p>
<h3 id="CF1503D"><a href="#CF1503D" class="headerlink" title="CF1503D"></a>CF1503D</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1503D">题目链接</a></p>
<p>考虑无解的必要条件，若存在 $a_i,b_i \le n$，那么必定存在一个 $a_j,b_j &gt; n$，显然无解。那么有解必然对于所有的 $i$ 使得 $a_i \le n,b_i &gt; n$ 或 $a_i &gt; n,b_i \le n$。</p>
<p>设 $i \in [1,n]$ 对应的另一边（比它大的数）是 $f(i)$，那么答案就是若干个 $i$ 升序排列，其对应的 $f(i)$ 降序，然后接上 $f(i)$ 升序，$i$ 降序。其中前面那段的 $i$ 在反面的贡献为 $1$，后面那段的 $i$ 在正面贡献为 $1$。那么按照 $i$ 排序，就是要让 $f(i)$ 分成两个下降子序列。</p>
<p>考虑判断是否有解，贪心地将新的 $f(i)$​ 加入前面两个下降子序列中最后一个数较小的且大于它的那个子序列中，但这样可能并不是最优解。</p>
<p>考虑什么时候一个数可以加入前面两个序列，结论：$\min\limits_{j&#x3D;1}^i a_j &gt; \max\limits_{j&#x3D;i+1}^n a_j$ 时，会有多种方案，这是显然的。那么考虑按照这个把原序列分段，每段有唯一分组方案，只是不知道哪个是前面的一段，哪个是后面的一段，显然讨论一下取最小即可。复杂度 $\Theta(n)$。</p>
<h3 id="CF1539F"><a href="#CF1539F" class="headerlink" title="CF1539F"></a>CF1539F</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1539F">题目链接</a></p>
<p>考虑中位数的经典套路，假设当前在求 $x$ 的答案，先假设当前区间中只有一个 $x$，把 $&lt;x$ 的数看成 $1$，$&gt;x$ 的数看成 $-1$，把 $x$ 看成 $0$ 那么 $x$ 的距离就是这个区间的和除以 $2$ 向下取整<strong>的绝对值</strong>。那么如果有多个 $x$，把一个 $x$ 看成 $0$，把其他的全看成 $1$ 或者 $-1$ 一定是最优的。因为考虑只有一个 $x$ 时，若 $x$ 排序后在中位数左边，加入一个 $x$ 会使中位数位置往右移动，最左边那个 $x$ 一定是最远的，$x$ 在右边时同理，最右边肯定是最远的。</p>
<p>考虑扫描值域，用线段树维护前缀和，每次修改一个后缀，询问 $i$ 时先把所有 $a_j &#x3D; a_i$ 的 $j$ 修改为 $1$ 和 $-1$ 都做一遍，询问 $i$ 右边最大值减去左边最小值，和右边最小值减去左边最大值（因为有负数的情况）取最大即可。复杂度 $\Theta(n\log n)$。</p>
<h3 id="CF1566F"><a href="#CF1566F" class="headerlink" title="CF1566F"></a>CF1566F</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1566F">题目链接</a></p>
<p>首先把所有已经包含点的区间扔掉，那么现在就剩一堆点然后一堆区间然后一堆点这样子。考虑每个点是怎么走的，可以先往左边走再回来再往右边，也可以先往右边再回来再往左边，也可以直往一个方向走。考虑两个相邻的点之间的区间，显然这些区间只可能被这两个点其中一个走，将它们按照左端点排序，左边那个点走的就是一个前缀的左端点最大值，右边的点走的就是后缀的右端点最小值。</p>
<p>设 $dp_{i,0&#x2F;1}$ 表示做完前 $i$ 个点，其中第 $i$ 个点是不是先往右走（或者不往右走）。转移的话直接枚举上个点走到那个前缀，算一下后缀 $\min$ 即可，$dp_{i,1}$ 的话要来回走，所以注意贡献要加两次。复杂度 $\Theta(n\log n)$，在于排序。</p>
<h3 id="CF1601D"><a href="#CF1601D" class="headerlink" title="CF1601D"></a>CF1601D</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1601D">题目链接</a></p>
<p>有个朴素的想法是全部按 $a_i$ 排序，先取 $a$ 小的，但是发现这样是错误的，因为有些是 $s_i &lt; a_i$ 的可以先取，然后还有 $s_j \ge a_j$ 的后取，而 $s_i &lt; a_j \le a_i \le s_j$。那么可以尝试将人分成两类，$s_i &lt; a_i$ 的和 $s_i \ge a_i$ 的。</p>
<p>还是根据刚刚的想法，设 $f_i$ 为当前高度为 $a_i$ 时的答案，把人按照 $a_i$ 排序。特殊地，对于 $s_i &lt; a_i$ 的人的 $f_i$，除了 $a_j \le s_i$ 的 $f_j$ 的最大值的贡献，还有 $s_i &lt; a_k \le a_i \le s_k$ 的所有 $k$ 的贡献，那么只要算出有多少个 $k$ 就行，二维数点 bit 维护。复杂度 $\Theta(n\log n)$。</p>
<h3 id="CF1601E"><a href="#CF1601E" class="headerlink" title="CF1601E"></a>CF1601E</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1601E">题目链接</a></p>
<p>考虑单次询问，从 $l$ 开始，在 $l,l+k,l+2k\cdots$ 位置都买一张 $[l,l+jk]$ 的最小值即可。</p>
<p>考虑多次询问，把所有 $l \operatorname{mod} k$ 同余的 $l$ 一起做，从后往前扫描线。维护所有 $p \operatorname{mod} k &#x3D; i$ 的所有位置的答案，当扫描到 $l$ 的时候，$ans_l$ 设为 $a_l$，然后找到 $cur&#x3D;\min\limits_{j&#x3D;l}^{l+k-1} a_j$，把 $l+k,l+2k,l+jk$ 的所有大于 $cur$ 的  $ans$ 换成 $cur$ 即可，单调栈维护。查询 $l$ 对应的 $r$ 时找到最大的 $j$ 使得 $l+jk\le r$，把 $[l,l+jk]$ 的所有关键点的 $ans$ 加起来即可。复杂度 $\Theta(n\log n)$，在于 st 表。</p>
<h3 id="CF1621F"><a href="#CF1621F" class="headerlink" title="CF1621F"></a>CF1621F</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1621F">题目链接</a></p>
<p>先把连续两个 $0$ 和 $1$ 的个数找出来，分别是 $x,y$。然后分讨一下，记 $cnt_0,cnt_1$ 为总 $0,1$ 的个数。</p>
<ul>
<li>$x&lt;y$</li>
</ul>
<p>显然操作序列肯定是形如 $2121\cdots21(232323)2$，括号处取到当且仅当 $b&gt;c$。当取完连续两个 $0$ 后序列一定长成若干个 $1$ 连着一个 $0$ 再有若干个 $1$，那就把首位的 $0$ 去掉剩下 $t$ 个 $0$，那么当 $b&gt;c$ 时显然可以把这 $t$ 个 $0$ 都删掉，此时剩下的 $y$ 不会变，还会剩下首位的 $0$ 能取就取就行。所以答案是 $x \times (a+b) + \max(0,b-c) \times (t+\min(y-x-1,cnt_0 - t)) + b$。</p>
<ul>
<li>$x\ge y$</li>
</ul>
<p>操作序列是形如 $1212\cdots 12(323232)[1]$，小括号取到当且仅当 $b&gt;c$，中括号取到当且仅当 $x&gt;y$。考虑小括号中最多取到多少个 $32$，那把相邻两个 $1$ 中间的 $0$ 个数统计出来，去掉 $0$ 的，把剩下的排序。在前 $y$ 次 $12$ 操作中可以尽量把中间连续的 $0$ 变成一个 $0$，即设连续长度为 $cnt_1 \le cnt_2\le \cdots \le cnt_k$，从头开始取 $cnt_i - 1$ 贪心能取就取即可，设最多把 $t$ 个 $cnt_1$ 变成 $1$，答案即 $y \times (a+b) + \max(0,b-c) \times t + [x&gt;y]a$。</p>
<p>复杂度 $\Theta(n\log n)$​，在于排序。</p>
<h3 id="CF1635F"><a href="#CF1635F" class="headerlink" title="CF1635F"></a>CF1635F</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1635F">题目链接</a></p>
<p>设 $L_i$ 为 $i$ 左边最大的 $j$ 使得 $w_j \le w_i$，$R_i$ 为 $i$ 右边最小的 $j$ 使得 $w_j \le w_i$。那么答案一定是 $(i,L_i),(i,R_i)$ 的形式。证明：设答案为 $(i,j),i \neq L_j$，那么 $x_i &lt; x_{L_j} &lt;x_j,w_i + w_{L_j} \le w_i + w_j$，因此 $(i,L_j)$ 更优。右边的情况同理。预处理这些点对，二维数点即可。复杂度 $\Theta(n\log n)$。</p>
<h3 id="CF1672H"><a href="#CF1672H" class="headerlink" title="CF1672H"></a>CF1672H</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1672H">题目链接</a></p>
<p>设 $00$ 个数 $x$ 和 $11$ 个数 $y$，每次删除一个区间，若为 $0(10101010)1$ 或 $1(01010101)0$ 则 $x,y$ 减 $1$，若 $1(01010)1$ 或 $0(1010101)0$，则 $x$ 或 $y$ 减 $1$。显然第一种更优，答案就是 $\max(x,y)+1$，前缀和即可。复杂度 $\Theta(n)$。</p>
<h3 id="CF1699E"><a href="#CF1699E" class="headerlink" title="CF1699E"></a>CF1699E</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1699E">题目链接</a></p>
<p>考虑扫描最小值 $l$，对每个数去看它拆开后最大值最能到多少。贪心是错误的，那么考虑 dp，设 $dp_{i,j}$ 为最小值为 $i$ 时 $j$ 能分到最大值最小是多少，从大到小转移，$dp_{i,j} &#x3D; \max(dp_{i+1,j},dp_{i,\frac{j}{i}})$，后面那个转移当且仅当 $i|j$ 且 $j\ge i^2$ 时成立，所以只有 $i$ 的倍数会改变，那么直接转移是 $\Theta(m\log m)$ 的。考虑求答案，$ans &#x3D; \min\limits_i(\max(dp_{i,j}) - i)$，注意到 $j$ 相同是 $dp_{i,j}$ 随 $i$ 降低是单调不增的，所以可以用个桶记录值用个指针扫就行。复杂度 $\Theta(m \log m)$。</p>
<h3 id="CF1793E"><a href="#CF1793E" class="headerlink" title="CF1793E"></a>CF1793E</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1793E">题目链接</a></p>
<p>显然肯定是 $a$ 最小的几个符合要求，因为如果有 $x&lt;y$ 且 $x$ 没满足 $y$ 满足了，交换 $x,y$ 肯定更优。那考虑二分答案，要让前 $mid$ 个符合要求，后面 $n-mid$ 都去读没人读的书了，这时有两种情况。</p>
<ul>
<li>$n-mid \ge k$，此时所有书都有人读，那么前 $mid$ 个人读一本书就行了，而且这本书还有后 $n-mid$ 个人中的 $n-mid-k+1$ 个人读，所以只要 $n-mid-k+1+mid\ge a_{mid}$ 即可。</li>
<li>$n-mid&lt;k$ 此时还有 $k-n+mid$ 个书要读，设 $f_i$ 为前 $i$ 个人都满足要求最多读几本书，显然 $f_i &#x3D; \max\limits_{j\le i-a_i} f_j + 1$。所以只要 $f_{mid} \ge k - n +mid$ 即可。</li>
</ul>
<p>复杂度 $\Theta(n+q\log n)$​。</p>
<h3 id="CF1720E"><a href="#CF1720E" class="headerlink" title="CF1720E"></a>CF1720E</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1720E">题目链接</a></p>
<p>设一开始有 $m$ 个颜色。</p>
<ul>
<li>$m&lt;k$，显然答案等于 $k-m$。</li>
<li>$m&gt;k$，下面证明答案不超过 $2$。<ul>
<li>第一个矩阵以 $(1,1)$ 开头拓展，把这个矩阵变成一个已有的颜色，拓展到最大的 $(t,t)$ 使得 $m’\ge k$。</li>
<li>若 $m’&gt;k$，第二个矩阵从 $(t+1,t+1)$ 往左上拓展，变成和第一个矩阵一样的颜色，每次覆盖 $2$ 个，所以最多使 $m’$ 减 $2$。</li>
<li>若最终的 $m’&#x3D;k-1$，那么把第二个矩阵的颜色变成一个没出现的颜色即可。</li>
<li>判断答案等于 $1$：可以先枚举长度 $len$，然后对于每种颜色，算出它的最小、最大的 $x,y$，显然符合要求的左上角是一个矩阵，差分一下就行。</li>
</ul>
</li>
</ul>
<p>复杂度 $\Theta(n^3)$​。</p>
<h3 id="CF1844F1"><a href="#CF1844F1" class="headerlink" title="CF1844F1"></a>CF1844F1</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1844F1">题目链接</a></p>
<p>注意到 $c\ge 0$ 时从小到大一定是最优解，$c&lt;0$ 时从大到小是最优解，但是字典序不一定最小。那就从前往后考虑每一个 $a_i$，枚举后面的 $a_j$ 看看能否把 $a_j$ 放到 $a_i$ 前面，令 $f(x)&#x3D;|x-c|$，只需判断 $f(a_j - a_{j - 1}) + f(a_{j+1} - a_j) + f(a_i - b_{i-1})-f(a_{j+1} - a_{j-1})-f(a_j - b_{i-1})-f(a_i - a_j)&#x3D;0$ 即可，$b_{i-1}$ 是已经确定的位置。复杂度 $\Theta(n^2)$。</p>
<p>F2 的结论没看懂&#x2F;kk</p>
<h3 id="CF1893D"><a href="#CF1893D" class="headerlink" title="CF1893D"></a>CF1893D</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1893D">题目链接</a></p>
<p>考虑对于一个单独的 $(s,d)$ 应该怎么填，肯定是以长度 $d$ 为一个区间，每个区间的数都不相同。</p>
<p>贪心地，考虑先满足 $d$ 大的 $(s_i,d_i)$，然后先用数量最多的 $d$ 个颜色，先放 $d$ 个，然后再重新取当前数量最多的 $d$ 个颜色再放，重复这个过程。先用最多的原因是若用了数量少的，那么那个颜色可能以后就不能用，我们肯定希望当前可用的颜色种类越多越好。考虑模拟这个过程，先把所有颜色放到大根堆里面，然后每次就取出堆顶的 $d$ 个弹出，然后把它们的个数减 $1$ 塞回去，再重新取 $d$ 个即可。</p>
<p>复杂度 $\Theta(n\log n)$。</p>
<h3 id="CF1919F2"><a href="#CF1919F2" class="headerlink" title="CF1919F2"></a>CF1919F2</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1919F2">题目链接</a></p>
<p>考虑将水看成流，其实就是一个网络流模型，$s\to i,a_i$ 和 $i\to t,b_i$ 和 $i\to i+1,c_i$。单点修改问最大流，显然可以贪心流，能流到 $t$ 就流到 $t$。</p>
<p>考虑两个区间怎么合并，需要知道什么。可以维护区间的几个信息：从这个区间流到右边的流大小，这个区间剩余的 $b_i$ 之和，从左边能流入最大的流使得不能再流了，还有答案分别记为 $out,rem,in,ans$。合并的时候，$ans&#x3D;ans_1 + ans_2 + \min(c_{r_1},out_1,in_2,rem_2)$，$in&#x3D;\min(in_1,rem_1+c_{r_1}-\min(out,c_{r+1}),rem_1+in_2-\min(c_{r_1},out_1,in_2))$，$out&#x3D;\max(0,\min(c_{r_1},out_1,in_2)-rem_{2})+out_2$。线段树维护即可，单点修改，全局查询。</p>
<p>复杂度 $\Theta(n\log n)$。</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/09/27/%E5%A5%BD%E9%A2%98%E5%88%86%E4%BA%AB%20II/" rel="prev" title="">
                  <i class="fa fa-angle-left"></i> 
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/09/27/tricks/" rel="next" title="">
                   <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">MiniLong</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">150k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">4:33</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/m1nilong" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
